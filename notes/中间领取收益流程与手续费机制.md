# 中间领取收益流程与手续费机制

## 概述

SYI 质押合约支持用户在质押期未到期时提前领取收益（利息），本金继续质押直到到期。本文档详细说明中间领取收益的完整流程，特别是 `feeRecipient` 在其中的作用。

## 核心函数

### withdrawInterest()

位置：`contracts/SYI-Staking/abstract/StakingBase.sol:284-380`

用户可以在质押期内随时调用此函数领取当前累计的利息，而本金继续质押。

## 完整流程解析

### 1. 前置验证

```solidity
require(!stakeRecord.status, "Already withdrawn");
require(
    block.timestamp < stakeRecord.originalEndTime,
    "Stake period ended, use unstake instead"
);
```

- 检查质押记录未被提取
- 检查质押期尚未到期（到期后必须使用 `unstake`）

### 2. 计算新增盈利

```solidity
uint256 currentValue = _calculateStakeReward(stakeRecord);
uint256 newProfit = currentValue - stakeRecord.amount;
require(newProfit > 0, "No new profit to withdraw");
```

- `currentValue`：从上次 `stakeTime` 开始复利计算的当前价值
- `newProfit`：新增盈利 = 当前价值 - 本金
- 必须有新增盈利才能提取

### 3. 兑换 SYI 为 USDT

```solidity
(uint256 usdtReceived, uint256 syiTokensUsed) = _swapSYIForReward(newProfit);
```

- 将 SYI 代币的盈利部分通过 Router 兑换为 USDT
- 返回实际收到的 USDT 数量和消耗的 SYI 数量

### 4. 分配推荐奖励

#### 4.1 Friend 奖励（直推 5%）

```solidity
uint256 friendReward = _distributeFriendReward(msg.sender, interestEarned);
```

- 基数：`interestEarned = usdtReceived`（兑换后的 USDT）
- 比例：5%
- 接收方：用户绑定的 `friend` 地址，若未绑定则给 `rootAddress`

#### 4.2 Team 奖励（最高 35%）

```solidity
address[] memory referralChain = getReferrals(msg.sender, maxD);
uint256 teamFee = _distributeTeamReward(referralChain, interestEarned);
```

- 基数：`interestEarned`（兑换后的 USDT）
- 比例：根据推荐链成员的等级（V1-V7），最高 35%
- 采用差额奖励机制分配给推荐链

### 5. 收取 Redemption Fee（1% 手续费）⭐

这是 `feeRecipient` 发挥作用的关键环节。

#### 5.1 计算费用基数

```solidity
uint256 userPayout = usdtReceived - friendReward - teamFee;
uint256 redemptionFeeUSDT = (userPayout * REDEMPTION_FEE_RATE) / BASIS_POINTS_DENOMINATOR;
```

**费用计算逻辑：**
- `userPayout`：扣除 friend 和 team 奖励后，用户应得部分
- `REDEMPTION_FEE_RATE = 100`（1% = 100 basis points）
- `BASIS_POINTS_DENOMINATOR = 10000`
- **最终费用 = userPayout × 1%**

**⚠️ 重要：Redemption Fee 仅从盈利部分收取**

- 手续费计算基数：`newProfit`（第301行：`currentValue - stakeRecord.amount`）
- 本金（`stakeRecord.amount`）完全不受影响，永远不变
- 流程：盈利部分 → 兑换成 USDT → 扣除推荐奖励 → 从剩余部分收取 1%
- 用户的质押本金在 `withdrawInterest` 和 `unstake` 中都保持不变

#### 5.2 兑换并转账费用

```solidity
if (redemptionFeeUSDT > 0 && feeRecipient != address(0)) {
    (, uint256 redemptionFeeSYIUsed) = _swapSYIForReward(redemptionFeeUSDT);
    emit RedemptionFeeCollected(
        msg.sender,
        stakeIndex,
        redemptionFeeSYIUsed,
        redemptionFeeUSDT,
        feeRecipient,
        block.timestamp
    );
}
```

**关键点：**
- 再次调用 `_swapSYIForReward` 将 SYI 兑换为 USDT
- **费用接收方：`feeRecipient` 地址**
- 发出 `RedemptionFeeCollected` 事件记录：
  - 用户地址
  - 质押索引
  - 消耗的 SYI 数量
  - 收取的 USDT 费用
  - 费用接收地址
  - 时间戳

### 6. 重置复利起点 ⚠️

```solidity
stakeRecord.stakeTime = uint40(block.timestamp);  // 重置为当前时间
// stakeRecord.amount 保持不变（本金不变）
// stakeRecord.originalEndTime 保持不变（到期时间不变）
stakeRecord.totalWithdrawn += uint160(usdtReceived);  // 记录累计提取
```

**复利重置机制：**
- `stakeTime` 更新为当前时间 → 下次复利从现在开始计算
- `amount`（本金）不变 → 用户本金继续质押
- `originalEndTime` 不变 → 原定到期时间不延长
- `totalWithdrawn` 累加 → 记录历史提取总额

### 7. 转账给用户

```solidity
IERC20(USDT).transfer(msg.sender, userPayout);
```

- 用户实际收到：`userPayout`（已扣除 friend、team、redemption fee）

### 8. 回收 SYI

```solidity
SYI.recycle(syiTokensUsed);
```

- 将兑换消耗的 SYI 回收到 SYI 合约

### 9. 发出事件

```solidity
emit InterestWithdrawn(...);
emit CompoundInterestReset(...);
```

## feeRecipient 的作用总结

### 定义位置

```solidity
address public feeRecipient;  // Line 249
uint256 public constant REDEMPTION_FEE_RATE = 100;  // 1%  Line 135
```

### 初始化

在构造函数中设置：

```solidity
constructor(
    address _usdt,
    address _router,
    address _rootAddress,
    address _feeRecipient
) {
    feeRecipient = _feeRecipient;
    // ...
}
```

### 管理函数

```solidity
function setFeeRecipient(address _feeRecipient) external onlyOwner {
    require(_feeRecipient != address(0), "Invalid fee recipient");
    address oldRecipient = feeRecipient;
    feeRecipient = _feeRecipient;
    emit FeeRecipientUpdated(oldRecipient, _feeRecipient);
}
```

- 只有 Owner 可以修改
- 不能设置为零地址

### 费用收取场景

`feeRecipient` 在以下两个场景收取 1% 费用：

1. **中间领取收益**（`withdrawInterest`）：
   - 时机：质押期内提前领取利息
   - 基数：用户应得部分（扣除 friend 和 team 后）
   - 公式：`(usdtReceived - friendReward - teamFee) × 1%`

2. **到期解押**（`unstake`）：
   - 时机：质押到期后完整解押
   - 基数：用户应得部分（扣除 friend 和 team 后）
   - 公式：`(usdtReceived - friendReward - teamFee) × 1%`

### 实际收益计算示例

假设用户中间领取收益，兑换得到 1000 USDT：

```
1. 兑换收到：1000 USDT
2. Friend 奖励：1000 × 5% = 50 USDT
3. Team 奖励：1000 × 35% = 350 USDT（假设满级）
4. 用户应得：1000 - 50 - 350 = 600 USDT
5. Redemption Fee：600 × 1% = 6 USDT → 转给 feeRecipient
6. 用户实际到手：600 USDT（注意：fee 已在步骤4前从池子扣除）
```

**实际代码执行：**
- 先从质押池兑换 `newProfit` 的 SYI，得到 1000 USDT
- 分配 50 USDT 给 friend
- 分配 350 USDT 给 team
- 再兑换 6 USDT 等值的 SYI 给 feeRecipient
- 转账 600 USDT 给用户

## 对比：unstake() 的费用收取

`unstake` 函数（第382-446行）也有相同的 redemption fee 机制：

```solidity
uint256 expectedRedemptionFeeUSDT = (userPayout * REDEMPTION_FEE_RATE) / BASIS_POINTS_DENOMINATOR;

if (expectedRedemptionFeeUSDT > 0 && feeRecipient != address(0)) {
    (, uint256 redemptionFeeSYIUsed) = _swapSYIForReward(expectedRedemptionFeeUSDT);
    emit RedemptionFeeCollected(...);
}
```

唯一区别：
- `withdrawInterest`：用户继续质押，只领取利息
- `unstake`：用户完全解押，领取本金+利息

## 设计意义

### 1. 协议可持续性
- 1% 费用为协议运营提供资金来源
- 费用比例合理，不影响用户体验

### 2. 灵活性
- `feeRecipient` 可以是：
  - 财务多签钱包
  - DAO 金库
  - 运营费用账户
  - 其他合约地址

### 3. 透明性
- 通过 `RedemptionFeeCollected` 事件链上公开
- 用户可以清晰看到费用流向

## 关键数据结构

### Record 结构

```solidity
struct Record {
    uint40 startTime;          // 原始质押时间（永不改变）
    uint40 stakeTime;          // 复利计算起点（withdrawInterest 时重置）
    uint40 originalEndTime;    // 原定到期时间（永不改变）
    uint160 amount;            // 本金（永不改变）
    uint160 totalWithdrawn;    // 累计提取金额（每次 withdrawInterest 累加）
    bool status;               // 是否已完全解押
    uint8 stakeIndex;          // 质押档位
}
```

## 风险控制

### 滑点保护

兑换 SYI 时使用 `_calculateMaxSYIInput` 计算最大输入，防止价格冲击。

### 零地址检查

```solidity
if (redemptionFeeUSDT > 0 && feeRecipient != address(0)) {
    // 收取费用
}
```

如果 `feeRecipient` 为零地址，不收取费用（但这在合约中被禁止）。

## 总结

**feeRecipient 的核心作用：**
1. 作为协议费用的接收地址
2. 在用户中间领取收益和最终解押时收取 1% 费用
3. 费用从用户应得部分（扣除推荐奖励后）计算
4. 通过 SYI → USDT 兑换实现费用收取
5. 所有费用收取都有链上事件记录，完全透明

**中间领取的特点：**
- 用户可以灵活领取已产生的利息
- 本金继续质押，不影响原定到期时间
- 复利计算重置，从领取时刻重新开始
- 每次领取都会收取 1% redemption fee
- 累计提取金额被记录，方便查询

**⚠️ 本金保护机制：**
- **质押本金（`stakeRecord.amount`）在任何操作中都不会被扣除手续费**
- 1% Redemption Fee **仅从收益部分**（`newProfit = currentValue - amount`）计算
- 无论是 `withdrawInterest`（中间领取）还是 `unstake`（到期解押），本金都完整保留
- 手续费只从「盈利兑换成的 USDT - 推荐奖励」后的剩余部分收取
