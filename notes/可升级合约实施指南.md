# SYI 系统可升级合约实施指南

## 目录

1. [概述](#概述)
2. [为什么需要可升级合约](#为什么需要可升级合约)
3. [可升级方案选择](#可升级方案选择)
4. [实施步骤](#实施步骤)
5. [部署流程](#部署流程)
6. [升级流程](#升级流程)
7. [安全注意事项](#安全注意事项)
8. [代码示例](#代码示例)

---

## 概述

本文档详细说明如何将 SYI 系统（包括 SYI 代币合约和 Staking 质押合约）改造为可升级合约架构。可升级合约允许在不更改合约地址的情况下修复 bug、添加功能或优化逻辑。

**当前架构**:
```
SYI.sol (mainnet)
  └── extends SYIBase.sol (abstract)

Staking.sol (mainnet)
  └── extends StakingBase.sol (abstract)
```

**目标架构**:
```
SYI (Proxy) ──> SYIImplementation (Logic)
Staking (Proxy) ──> StakingImplementation (Logic)
```

---

## 为什么需要可升级合约

### 当前系统的局限性

1. **代码不可变性**: 一旦部署，合约逻辑无法修改
2. **Bug 无法修复**: 发现漏洞后必须重新部署，损失所有状态
3. **功能扩展困难**: 添加新功能需要用户迁移到新合约
4. **流动性重建成本高**: 重新部署需要重新添加流动性，影响价格

### 可升级合约的优势

1. **逻辑可升级**: 修复 bug、优化算法、添加功能
2. **保留合约地址**: 用户无需更改交互地址
3. **保留状态数据**: 质押记录、余额、推荐关系等数据不丢失
4. **降低迁移成本**: 无需重建流动性池，无需用户手动迁移

---

## 可升级方案选择

### 方案对比

| 方案 | 优点 | 缺点 | 推荐度 |
|------|------|------|--------|
| **透明代理 (Transparent Proxy)** | 简单易用，OpenZeppelin 官方支持 | Gas 成本稍高 | ⭐⭐⭐⭐⭐ |
| **UUPS 代理** | Gas 成本低，升级逻辑在实现合约 | 实现复杂，风险高 | ⭐⭐⭐ |
| **钻石代理 (Diamond)** | 可模块化升级 | 过于复杂，学习成本高 | ⭐⭐ |

### 推荐方案: **透明代理 (Transparent Proxy)**

**理由**:
- OpenZeppelin 官方维护，久经考验
- 安全性高，有完善的审计报告
- 开发简单，文档齐全
- 社区支持度高

**核心机制**:
```
用户调用 → Proxy 合约 → delegatecall → Implementation 合约
                ↓
            存储所有状态
```

---

## 实施步骤

### 阶段 1: 环境准备

#### 1.1 安装依赖

```bash
npm install --save-dev @openzeppelin/hardhat-upgrades
```

#### 1.2 更新 hardhat.config.js

```javascript
require("@nomicfoundation/hardhat-toolbox");
require("@openzeppelin/hardhat-upgrades"); // 新增

module.exports = {
  solidity: {
    version: "0.8.28",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  // ... 其他配置
};
```

---

### 阶段 2: 合约改造

#### 2.1 SYI 代币合约改造

**关键变更**:
1. 移除 `constructor`，改为 `initialize` 函数
2. 继承 `Initializable` 和 `UUPSUpgradeable`
3. 将 `immutable` 变量改为普通状态变量
4. 添加存储间隙 (`__gap`)

**改造前** (`contracts/SYI/mainnet/SYI.sol`):
```solidity
contract SYI is SYIBase {
    constructor(
        address _usdt,
        address _router,
        address _staking
    ) SYIBase(_usdt, _router, _staking) {}
}
```

**改造后** (`contracts/SYI/mainnet/SYIUpgradeable.sol`):
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {SYIBaseUpgradeable} from "../abstract/SYIBaseUpgradeable.sol";
import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract SYIUpgradeable is Initializable, SYIBaseUpgradeable {
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers(); // 防止实现合约被初始化
    }

    function initialize(
        address _usdt,
        address _router,
        address _staking
    ) public initializer {
        __SYIBase_init(_usdt, _router, _staking);
    }

    // 环境特定常量 - 主网值
    function getDelayedBuyPeriod() internal pure override returns (uint256) {
        return 30 days;
    }

    function getPresaleDuration() internal pure override returns (uint256) {
        return 30 days;
    }
}
```

#### 2.2 SYIBase 合约改造

**关键变更**:
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {ERC20Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

abstract contract SYIBaseUpgradeable is
    Initializable,
    ERC20Upgradeable,
    OwnableUpgradeable,
    UUPSUpgradeable
{
    // ========================================================================
    // 状态变量 (原 immutable 改为普通变量)
    // ========================================================================

    address public USDT;
    IUniswapV2Router02 public uniswapV2Router;
    IStaking public staking;

    IUniswapV2Pair public uniswapV2Pair;
    uint256 public coldTime;
    uint256 public presaleStartTime;
    // ... 其他状态变量

    // ========================================================================
    // 初始化函数 (替代 constructor)
    // ========================================================================

    function __SYIBase_init(
        address _usdt,
        address _router,
        address _staking
    ) internal onlyInitializing {
        __ERC20_init("Stable Yield Investment", "SYI");
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();

        if (_usdt == address(0) || _router == address(0) || _staking == address(0)) {
            revert ZeroAddress();
        }

        USDT = _usdt;
        uniswapV2Router = IUniswapV2Router02(_router);
        staking = IStaking(_staking);

        coldTime = 10 seconds;
        presaleDuration = getPresaleDuration();
        presaleStartTime = block.timestamp;
        presaleActive = true;
        contractDeployTime = block.timestamp;

        _mint(msg.sender, 100_000_000 ether);
    }

    // ========================================================================
    // UUPS 升级授权 (只有 owner 可以升级)
    // ========================================================================

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    // ========================================================================
    // 存储间隙 - 为未来升级预留空间
    // ========================================================================

    /**
     * @dev 预留 50 个存储槽位用于未来升级
     * 重要: 添加新状态变量时，需要减少 __gap 数组大小
     */
    uint256[50] private __gap;
}
```

#### 2.3 Staking 合约改造

**改造前** (`contracts/SYI-Staking/mainnet/Staking.sol`):
```solidity
contract Staking is StakingBase {
    constructor(
        address _usdt,
        address _router,
        address _rootAddress,
        address _feeRecipient
    ) StakingBase(_usdt, _router, _rootAddress, _feeRecipient) {}
}
```

**改造后** (`contracts/SYI-Staking/mainnet/StakingUpgradeable.sol`):
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {StakingBaseUpgradeable} from "../abstract/StakingBaseUpgradeable.sol";
import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract StakingUpgradeable is Initializable, StakingBaseUpgradeable {
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(
        address _usdt,
        address _router,
        address _rootAddress,
        address _feeRecipient
    ) public initializer {
        __StakingBase_init(_usdt, _router, _rootAddress, _feeRecipient);
    }

    // 环境特定常量 - 主网值
    function getAPYRate1D() internal pure override returns (uint256) {
        return 1003000000000000000; // 0.3% daily
    }

    function getAPYRate30D() internal pure override returns (uint256) {
        return 1006000000000000000; // 0.6% daily
    }

    // ... 其他环境常量

    function getCompoundTimeUnit() internal pure override returns (uint256) {
        return 1 days; // 主网按天复利
    }

    uint256[50] private __gap; // 预留升级空间
}
```

#### 2.4 StakingBase 合约改造

**关键变更**:
```solidity
abstract contract StakingBaseUpgradeable is
    Initializable,
    OwnableUpgradeable,
    UUPSUpgradeable,
    ReentrancyGuardUpgradeable
{
    // 原 immutable 变量改为普通状态变量
    address public USDT;
    IUniswapV2Router02 public ROUTER;
    address public rootAddress;
    address public feeRecipient;

    // 其他状态变量
    ISYI public SYI;
    mapping(address => StakeRecord[]) public stakes;
    // ...

    function __StakingBase_init(
        address _usdt,
        address _router,
        address _rootAddress,
        address _feeRecipient
    ) internal onlyInitializing {
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();
        __ReentrancyGuard_init();

        USDT = _usdt;
        ROUTER = IUniswapV2Router02(_router);
        rootAddress = _rootAddress;
        feeRecipient = _feeRecipient;
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    uint256[50] private __gap;
}
```

---

### 阶段 3: 部署脚本改造

#### 3.1 创建可升级部署脚本

新建 `scripts/deploySYIUpgradeable.js`:

```javascript
const hre = require("hardhat");
const { upgrades } = require("hardhat");
const fs = require("fs");
const path = require("path");

async function main() {
  console.log("\n==========================================");
  console.log("开始部署可升级 SYI 系统");
  console.log("==========================================\n");

  const [deployer, feeRecipientWallet, rootWallet] = await hre.ethers.getSigners();

  console.log("部署账户:", deployer.address);
  console.log("质押手续费接收钱包:", feeRecipientWallet.address);
  console.log("Root 钱包:", rootWallet.address);

  // ========================================
  // 1. BSC 主网合约地址
  // ========================================
  const usdtAddress = "0x55d398326f99059fF775485246999027B3197955";
  const routerAddress = "0x10ED43C718714eb63d5aA57B78B54704E256024E";
  const factoryAddress = "0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73";

  console.log("✅ USDT:", usdtAddress);
  console.log("✅ Router:", routerAddress);
  console.log("✅ Factory:", factoryAddress);

  // ========================================
  // 2. 部署可升级 Staking 合约
  // ========================================
  console.log("\n[1/2] 部署可升级 Staking 合约...");

  const StakingUpgradeable = await hre.ethers.getContractFactory(
    "contracts/SYI-Staking/mainnet/StakingUpgradeable.sol:StakingUpgradeable"
  );

  const staking = await upgrades.deployProxy(
    StakingUpgradeable,
    [
      usdtAddress,
      routerAddress,
      rootWallet.address,
      feeRecipientWallet.address
    ],
    {
      initializer: "initialize",
      kind: "uups" // 使用 UUPS 代理模式
    }
  );

  await staking.waitForDeployment();
  const stakingAddress = await staking.getAddress();
  console.log("✅ Staking 代理合约:", stakingAddress);
  console.log("✅ Staking 实现合约:", await upgrades.erc1967.getImplementationAddress(stakingAddress));

  // ========================================
  // 3. 部署可升级 SYI 代币合约
  // ========================================
  console.log("\n[2/2] 部署可升级 SYI 代币合约...");

  const SYIUpgradeable = await hre.ethers.getContractFactory(
    "contracts/SYI/mainnet/SYIUpgradeable.sol:SYIUpgradeable"
  );

  const syi = await upgrades.deployProxy(
    SYIUpgradeable,
    [
      usdtAddress,
      routerAddress,
      stakingAddress
    ],
    {
      initializer: "initialize",
      kind: "uups"
    }
  );

  await syi.waitForDeployment();
  const syiAddress = await syi.getAddress();
  console.log("✅ SYI 代理合约:", syiAddress);
  console.log("✅ SYI 实现合约:", await upgrades.erc1967.getImplementationAddress(syiAddress));

  // ========================================
  // 4. 配置阶段（与原脚本相同）
  // ========================================
  console.log("\n==========================================");
  console.log("开始配置合约关联关系");
  console.log("==========================================\n");

  // 初始化白名单
  console.log("[1/3] 初始化 SYI 白名单...");
  await syi.initializeWhitelist();
  console.log("✅ 白名单初始化完成");

  // 配置 Staking 的 SYI 地址
  console.log("\n[2/3] 配置 Staking.setSYI()...");
  await staking.setSYI(syiAddress);
  console.log("✅ Staking 配置完成");

  // 创建交易对
  console.log("\n[3/3] 创建 SYI/USDT 交易对...");
  const factory = await hre.ethers.getContractAt(
    "contracts/SYI/interfaces/IUniswapV2Factory.sol:IUniswapV2Factory",
    factoryAddress
  );
  await factory.createPair(syiAddress, usdtAddress);
  const pairAddress = await factory.getPair(syiAddress, usdtAddress);
  console.log("✅ 交易对创建成功:", pairAddress);

  await syi.setPair(pairAddress);
  console.log("✅ Pair 地址设置完成");

  // ========================================
  // 5. 保存部署信息
  // ========================================
  const deployment = {
    network: hre.network.name,
    timestamp: new Date().toISOString(),
    deployer: deployer.address,
    upgradeable: true, // 标记为可升级部署
    contracts: {
      SYI: {
        proxy: syiAddress,
        implementation: await upgrades.erc1967.getImplementationAddress(syiAddress)
      },
      Staking: {
        proxy: stakingAddress,
        implementation: await upgrades.erc1967.getImplementationAddress(stakingAddress)
      },
      USDT: usdtAddress,
      Router: routerAddress,
      Factory: factoryAddress,
      Pair: pairAddress
    }
  };

  const outputPath = path.join(__dirname, "..", ".openzeppelin", "syi-deployment-upgradeable.json");
  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, JSON.stringify(deployment, null, 2));
  console.log("\n✅ 部署信息已保存到:", outputPath);

  // 后续流程：添加流动性等（与原脚本相同）
  // ...

  console.log("\n==========================================");
  console.log("✅ 可升级 SYI 系统部署完成！");
  console.log("==========================================");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

---

## 部署流程

### 本地测试网部署

#### 1. 启动 Fork 节点

```bash
npx hardhat node --hostname 0.0.0.0 --port 8545 \
  --fork https://rpc.tornadoeth.cash/bsc \
  --fork-block-number 64340000
```

#### 2. 编译可升级合约

```bash
npx hardhat compile
```

#### 3. 部署可升级系统

```bash
npx hardhat run scripts/deploySYIUpgradeable.js --network localhost
```

#### 4. 验证部署

检查 `.openzeppelin/` 目录下生成的配置文件:
- `unknown-31337.json`: 代理和实现合约地址映射
- `syi-deployment-upgradeable.json`: 部署信息

### BSC 主网部署

#### 1. 配置部署账户

在 `hardhat.config.js` 中添加:

```javascript
bsc: {
  url: "https://bsc-dataseed1.binance.org/",
  chainId: 56,
  accounts: [process.env.DEPLOYER_PRIVATE_KEY]
}
```

#### 2. 部署到主网

```bash
npx hardhat run scripts/deploySYIUpgradeable.js --network bsc
```

#### 3. 验证合约

```bash
npx hardhat verify --network bsc <PROXY_ADDRESS>
npx hardhat verify --network bsc <IMPLEMENTATION_ADDRESS>
```

---

## 升级流程

### 场景示例: 修复 Bug 或添加功能

假设我们需要在 Staking 合约中添加新功能：允许管理员暂停质押。

#### 步骤 1: 创建新版本实现合约

新建 `contracts/SYI-Staking/mainnet/StakingUpgradeableV2.sol`:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {StakingUpgradeable} from "./StakingUpgradeable.sol";
import {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";

/**
 * @title StakingUpgradeableV2
 * @notice V2 版本：添加暂停功能
 */
contract StakingUpgradeableV2 is StakingUpgradeable, PausableUpgradeable {
    // 新增状态变量
    bool public emergencyMode;

    // 重新初始化函数（可选，仅在需要添加新初始化逻辑时）
    function initializeV2() public reinitializer(2) {
        __Pausable_init();
        emergencyMode = false;
    }

    // 覆盖 stake 函数，添加暂停检查
    function stake(
        uint160 _amount,
        uint8 _stakeIndex
    ) external override whenNotPaused nonReentrant {
        super.stake(_amount, _stakeIndex);
    }

    // 新增管理员函数
    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    function setEmergencyMode(bool _enabled) external onlyOwner {
        emergencyMode = _enabled;
    }

    // 注意：需要调整 __gap 大小
    // 减少 1 个槽位（因为新增了 emergencyMode）
    uint256[49] private __gap_v2;
}
```

#### 步骤 2: 编写升级脚本

新建 `scripts/upgradeStaking.js`:

```javascript
const hre = require("hardhat");
const { upgrades } = require("hardhat");

async function main() {
  console.log("\n==========================================");
  console.log("开始升级 Staking 合约到 V2");
  console.log("==========================================\n");

  // 从部署记录中读取代理地址
  const deployment = require("../.openzeppelin/syi-deployment-upgradeable.json");
  const proxyAddress = deployment.contracts.Staking.proxy;

  console.log("当前代理地址:", proxyAddress);
  console.log("当前实现地址:", deployment.contracts.Staking.implementation);

  // 验证升级安全性
  console.log("\n[1/3] 验证升级兼容性...");
  const StakingV2 = await hre.ethers.getContractFactory(
    "contracts/SYI-Staking/mainnet/StakingUpgradeableV2.sol:StakingUpgradeableV2"
  );

  // 执行升级
  console.log("\n[2/3] 执行升级...");
  const upgraded = await upgrades.upgradeProxy(proxyAddress, StakingV2);
  await upgraded.waitForDeployment();

  const newImplementation = await upgrades.erc1967.getImplementationAddress(proxyAddress);
  console.log("✅ 升级成功!");
  console.log("代理地址（不变）:", proxyAddress);
  console.log("新实现地址:", newImplementation);

  // 调用新的初始化函数
  console.log("\n[3/3] 初始化 V2 功能...");
  await upgraded.initializeV2();
  console.log("✅ V2 初始化完成");

  // 验证升级
  const isPaused = await upgraded.paused();
  const emergencyMode = await upgraded.emergencyMode();
  console.log("\n验证新功能:");
  console.log("- 是否暂停:", isPaused);
  console.log("- 紧急模式:", emergencyMode);

  console.log("\n==========================================");
  console.log("✅ 升级完成！");
  console.log("==========================================");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

#### 步骤 3: 执行升级

```bash
# 本地测试网升级
npx hardhat run scripts/upgradeStaking.js --network localhost

# BSC 主网升级
npx hardhat run scripts/upgradeStaking.js --network bsc
```

#### 步骤 4: 验证升级结果

```javascript
// scripts/verifyUpgrade.js
const hre = require("hardhat");

async function main() {
  const deployment = require("../.openzeppelin/syi-deployment-upgradeable.json");
  const proxyAddress = deployment.contracts.Staking.proxy;

  const staking = await hre.ethers.getContractAt(
    "contracts/SYI-Staking/mainnet/StakingUpgradeableV2.sol:StakingUpgradeableV2",
    proxyAddress
  );

  // 验证旧数据未丢失
  const owner = await staking.owner();
  console.log("Owner:", owner);

  // 验证新功能可用
  const isPaused = await staking.paused();
  console.log("Paused:", isPaused);

  // 测试新功能
  console.log("\n测试暂停功能...");
  await staking.pause();
  console.log("✅ 已暂停");

  await staking.unpause();
  console.log("✅ 已恢复");
}

main();
```

---

## 安全注意事项

### 1. 存储布局冲突 (Storage Layout Collision)

**问题**: 升级时修改状态变量顺序会导致数据错乱

**错误示例**:
```solidity
// V1
contract StakingV1 {
    address public owner;
    uint256 public totalStaked;
}

// V2 - 错误：插入新变量到中间
contract StakingV2 {
    address public owner;
    bool public paused;     // ❌ 错误：会覆盖 totalStaked 的存储位置
    uint256 public totalStaked;
}
```

**正确做法**:
```solidity
// V2 - 正确：只在末尾添加
contract StakingV2 {
    address public owner;
    uint256 public totalStaked;
    bool public paused;     // ✅ 正确：添加到末尾
}
```

### 2. Immutable 变量限制

**问题**: 可升级合约不能使用 `immutable` 或 `constructor`

**错误示例**:
```solidity
contract StakingUpgradeable {
    address public immutable USDT; // ❌ 不能使用 immutable

    constructor(address _usdt) { // ❌ 不能使用 constructor
        USDT = _usdt;
    }
}
```

**正确做法**:
```solidity
contract StakingUpgradeable {
    address public USDT; // ✅ 普通状态变量

    function initialize(address _usdt) public initializer {
        USDT = _usdt;
    }
}
```

### 3. 初始化函数保护

**问题**: `initialize` 必须防止被多次调用

**错误示例**:
```solidity
function initialize() public { // ❌ 任何人都可以重复调用
    owner = msg.sender;
}
```

**正确做法**:
```solidity
function initialize() public initializer { // ✅ 使用 initializer 修饰符
    __Ownable_init(msg.sender);
}
```

### 4. 升级权限管理

**问题**: 必须严格限制升级权限

**推荐做法**:
```solidity
function _authorizeUpgrade(address newImplementation)
    internal
    override
    onlyOwner // ✅ 只有 owner 可以升级
{
    // 可选：添加额外验证
    require(newImplementation != address(0), "Invalid implementation");
}
```

**多签钱包升级** (推荐用于主网):
```solidity
// 使用 Gnosis Safe 多签钱包作为 owner
// 升级需要多人签名确认
```

### 5. 选择器冲突 (Selector Clash)

**问题**: 透明代理模式需要确保代理函数不与实现函数冲突

**透明代理自动处理**:
- Admin 调用 → 执行代理函数（如 `upgradeTo`）
- 普通用户调用 → 委托到实现合约

**注意**: 使用 UUPS 模式（推荐）可以避免此问题

### 6. delegatecall 注意事项

**关键点**:
- `delegatecall` 在代理合约的上下文中执行
- `msg.sender` 保持为原始调用者
- 所有状态变更写入代理合约存储

**示例**:
```
用户 (0xAAA) → Proxy (0xBBB) → delegatecall → Implementation (0xCCC)
              ↓
          msg.sender = 0xAAA (保持不变)
          存储写入 Proxy (0xBBB)
```

---

## 测试策略

### 升级前测试清单

```javascript
// test/upgrade.test.js
const { expect } = require("chai");
const { ethers, upgrades } = require("hardhat");

describe("Staking Upgrade Test", function () {
  let staking, stakingV2;
  let owner, user1;

  beforeEach(async function () {
    [owner, user1] = await ethers.getSigners();

    // 部署 V1
    const Staking = await ethers.getContractFactory("StakingUpgradeable");
    staking = await upgrades.deployProxy(Staking, [
      /* init params */
    ]);

    // 用户进行质押
    await staking.connect(user1).stake(ethers.parseEther("100"), 0);
  });

  it("应该保留升级前的数据", async function () {
    const stakesBefore = await staking.stakes(user1.address, 0);

    // 升级到 V2
    const StakingV2 = await ethers.getContractFactory("StakingUpgradeableV2");
    stakingV2 = await upgrades.upgradeProxy(staking.getAddress(), StakingV2);

    const stakesAfter = await stakingV2.stakes(user1.address, 0);
    expect(stakesAfter.amount).to.equal(stakesBefore.amount);
  });

  it("应该支持新功能", async function () {
    const StakingV2 = await ethers.getContractFactory("StakingUpgradeableV2");
    stakingV2 = await upgrades.upgradeProxy(staking.getAddress(), StakingV2);
    await stakingV2.initializeV2();

    // 测试暂停功能
    await stakingV2.pause();
    expect(await stakingV2.paused()).to.be.true;
  });

  it("应该拒绝未授权的升级", async function () {
    const StakingV2 = await ethers.getContractFactory("StakingUpgradeableV2");
    await expect(
      upgrades.upgradeProxy(staking.getAddress(), StakingV2.connect(user1))
    ).to.be.reverted;
  });
});
```

---

## 常见问题 (FAQ)

### Q1: 升级会丢失数据吗？

**A**: 不会。代理合约存储所有数据，升级只替换逻辑合约。

### Q2: 升级需要用户做什么？

**A**: 用户无需任何操作，合约地址不变。

### Q3: 可以回滚到旧版本吗？

**A**: 可以，只要旧版本合约仍然兼容当前存储布局。

### Q4: 升级成本是多少？

**A**: 升级交易的 Gas 费用，通常在 200,000-500,000 Gas。

### Q5: 如何确保升级安全？

**A**:
1. 完整的自动化测试
2. 使用 OpenZeppelin 插件的 `validateUpgrade` 检查
3. 在测试网充分测试
4. 使用多签钱包管理升级权限
5. 考虑使用时间锁（Timelock）延迟升级

---

## 最佳实践总结

### ✅ 推荐做法

1. **使用 UUPS 代理模式** - 比透明代理 Gas 成本低
2. **预留存储间隙** - 添加 `uint256[50] private __gap;`
3. **版本化初始化** - 使用 `reinitializer(2)` 区分版本
4. **多签管理** - 使用 Gnosis Safe 管理 owner
5. **全面测试** - 覆盖数据迁移、新功能、权限控制
6. **文档记录** - 记录每次升级的原因和变更内容

### ❌ 避免做法

1. **不要修改状态变量顺序** - 会导致数据错乱
2. **不要使用 `selfdestruct`** - 可升级合约禁止使用
3. **不要在 constructor 中初始化** - 使用 `initialize`
4. **不要删除旧变量** - 保留并标记为废弃
5. **不要跳过测试** - 升级失败可能导致资金损失

---

## 总结

通过实施可升级合约架构，SYI 系统将获得以下能力:

1. **持续迭代**: 快速修复 bug 和优化功能
2. **降低风险**: 无需迁移用户和流动性
3. **提升信心**: 用户知道项目有持续维护能力
4. **灵活应对**: 面对市场变化和监管要求快速调整

**下一步建议**:
1. 在本地测试网完整测试可升级部署
2. 在 BSC 测试网部署并执行一次升级演练
3. 编写详细的升级 SOP（标准操作流程）
4. 配置多签钱包管理升级权限
5. 准备主网升级应急预案

---

## 参考资源

- [OpenZeppelin Upgrades Plugin](https://docs.openzeppelin.com/upgrades-plugins/1.x/)
- [Writing Upgradeable Contracts](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable)
- [Proxy Patterns](https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies)
- [Storage Gaps](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#storage-gaps)
- [Gnosis Safe](https://safe.global/)

---

**文档版本**: v1.0
**最后更新**: 2025-11-29
**作者**: Claude Code
**适用系统**: SYI Token + Staking System
