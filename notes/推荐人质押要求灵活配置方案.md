# 推荐人质押要求灵活配置方案

## 一、需求背景

### 当前问题
在 `lockReferral()` 函数中（StakingBase.sol:447-476），存在以下验证逻辑：

```solidity
if (_referrer != rootAddress && balanceOf(_referrer) <= 1 ether) {
    revert InvalidReferrer();
}
```

**问题描述**：
- 推荐人必须已经质押 > 1 SYI 才能成为合法推荐人
- 这导致初期用户难以推广（需要先质押才能推荐别人）
- 系统希望能够灵活配置此要求

### 用户需求
1. **灵活开关**：管理员可以配置是否强制推荐人必须质押
2. **状态继承**：用户绑定推荐人时的系统规则永久生效
   - 如果在"不强制质押"模式下绑定，该用户未来永远不受质押要求限制
   - 如果在"强制质押"模式下绑定，该用户永远受质押要求限制
3. **向前兼容**：已绑定的推荐关系不受新规则影响

---

## 二、设计方案

### 2.1 核心思路

引入**双重记录机制**：
1. **全局配置**：当前系统是否要求推荐人质押（可动态切换）
2. **用户快照**：记录每个用户绑定推荐人时的系统配置状态（不可变）

### 2.2 状态变量设计

```solidity
// =========================================================================
// REFERRAL REQUIREMENT CONFIGURATION
// =========================================================================

/**
 * @notice 当前系统是否要求推荐人必须质押
 * @dev true = 推荐人必须持有 > 1 sSYI，false = 无质押要求
 */
bool public requireReferrerStaked;

/**
 * @notice 记录用户绑定推荐人时的系统配置快照
 * @dev mapping(用户地址 => 绑定时是否要求推荐人质押)
 * @dev 一旦绑定，该状态永久生效
 */
mapping(address => bool) private _userReferralRequirementSnapshot;

/**
 * @notice 记录用户是否已经绑定过推荐人
 * @dev 用于区分"未绑定"和"已绑定但规则宽松"的情况
 */
// 复用现有的 _hasLocked 映射，无需新增
```

### 2.3 配置函数

```solidity
/**
 * @notice 设置推荐人质押要求（仅限管理员）
 * @param _required 是否要求推荐人必须质押
 * @dev 只影响未来的新绑定，不影响已绑定用户
 */
function setRequireReferrerStaked(bool _required) external onlyOwner {
    bool oldValue = requireReferrerStaked;
    requireReferrerStaked = _required;

    emit ReferrerStakeRequirementUpdated(oldValue, _required, block.timestamp);
}
```

### 2.4 推荐人验证逻辑修改

#### 修改前（StakingBase.sol:447-476）
```solidity
function lockReferral(address _referrer) external {
    address user = msg.sender;

    if (_referrals[user] != address(0)) revert AlreadyBound();
    if (user == rootAddress) revert CannotReferSelf();

    if (_referrer == address(0)) {
        _referrer = rootAddress;
    }

    if (_referrer == user) revert CannotReferSelf();

    // ❌ 硬编码：强制要求推荐人质押
    if (_referrer != rootAddress && balanceOf(_referrer) <= 1 ether) {
        revert InvalidReferrer();
    }

    _referrals[user] = _referrer;
    _children[_referrer].push(user);
    _hasLocked[user] = true;
    // ...
}
```

#### 修改后
```solidity
function lockReferral(address _referrer) external {
    address user = msg.sender;

    if (_referrals[user] != address(0)) revert AlreadyBound();
    if (user == rootAddress) revert CannotReferSelf();

    if (_referrer == address(0)) {
        _referrer = rootAddress;
    }

    if (_referrer == user) revert CannotReferSelf();

    // ✅ 新逻辑：根据当前系统配置决定是否检查质押
    if (requireReferrerStaked) {
        if (_referrer != rootAddress && balanceOf(_referrer) <= 1 ether) {
            revert InvalidReferrer();
        }
    }

    // ⭐ 关键：记录用户绑定时的系统配置快照
    _userReferralRequirementSnapshot[user] = requireReferrerStaked;

    _referrals[user] = _referrer;
    _children[_referrer].push(user);
    _hasLocked[user] = true;

    // ... 其他逻辑保持不变
}
```

### 2.5 查询函数（可选）

提供查询接口，方便前端/审计：

```solidity
/**
 * @notice 查询用户绑定推荐人时的质押要求快照
 * @param user 用户地址
 * @return wasRequired 该用户绑定时是否要求推荐人质押
 * @return hasLocked 该用户是否已绑定
 */
function getUserReferralRequirement(address user)
    external
    view
    returns (bool wasRequired, bool hasLocked)
{
    wasRequired = _userReferralRequirementSnapshot[user];
    hasLocked = _hasLocked[user];
}

/**
 * @notice 查询某个用户能否推荐其他人
 * @param potentialReferrer 潜在推荐人地址
 * @return canRefer 是否可以成为推荐人
 * @return reason 如果不能，原因说明
 */
function canBeReferrer(address potentialReferrer)
    external
    view
    returns (bool canRefer, string memory reason)
{
    if (potentialReferrer == rootAddress) {
        return (true, "");
    }

    if (!requireReferrerStaked) {
        return (true, "");
    }

    if (balanceOf(potentialReferrer) <= 1 ether) {
        return (false, "Referrer must have staked more than 1 SYI");
    }

    return (true, "");
}
```

---

## 三、事件定义

```solidity
/**
 * @notice 推荐人质押要求配置变更事件
 * @param oldValue 旧配置值
 * @param newValue 新配置值
 * @param timestamp 变更时间戳
 */
event ReferrerStakeRequirementUpdated(
    bool oldValue,
    bool newValue,
    uint256 timestamp
);
```

---

## 四、影响分析

### 4.1 对现有代码的影响

#### ✅ **无影响的部分**
1. **推荐链遍历**（`getReferrals`）：只读操作，不涉及验证
2. **团队奖励分配**（`_distributeTeamReward`）：只检查 `isPreacher`，不检查推荐人质押状态
3. **质押流程**（`stake`）：只检查 `isBindReferral`，不关心绑定时的规则
4. **提现流程**（`unstake`, `withdrawInterest`）：不涉及推荐人验证

#### ⚠️ **需要测试的部分**
1. **`lockReferral()` 函数**：核心修改点，需要全面测试
   - 测试在 `requireReferrerStaked = true` 时的行为
   - 测试在 `requireReferrerStaked = false` 时的行为
   - 测试切换配置后，已绑定用户不受影响

2. **`_syncExistingInvestmentToReferralChain()`**：
   - 位置：StakingBase.sol:1095-1106
   - 分析：用户绑定推荐人后，如果已有质押本金会同步到上级
   - 影响：**无**，只是读取和更新团队 KPI，不涉及验证

### 4.2 边界情况处理

| 场景 | 系统配置 | 推荐人状态 | 结果 |
|------|---------|----------|------|
| 用户A首次绑定 | `requireReferrerStaked = true` | 推荐人已质押 > 1 SYI | ✅ 绑定成功，快照记录为 `true` |
| 用户B首次绑定 | `requireReferrerStaked = true` | 推荐人未质押 | ❌ 抛出 `InvalidReferrer` |
| 用户C首次绑定 | `requireReferrerStaked = false` | 推荐人未质押 | ✅ 绑定成功，快照记录为 `false` |
| 用户C推荐用户D | 系统切换为 `true` | 用户C未质押 | ⚠️ **关键场景** |

#### **关键场景详细分析**：用户C推荐用户D

**背景**：
- 用户C在系统 `requireReferrerStaked = false` 时绑定了推荐人
- 用户C从未质押（`balanceOf(C) = 0`）
- 系统后来切换为 `requireReferrerStaked = true`
- 用户D想绑定C为推荐人

**期望行为**：
用户D **应该能成功绑定**，因为：
1. C在绑定时系统不要求质押，这个"豁免权"应该传递下去
2. C的推荐能力应该基于其绑定时的规则，而非当前系统规则

**需要额外逻辑**：

```solidity
function lockReferral(address _referrer) external {
    // ... 前置检查 ...

    // ✅ 修改后的验证逻辑
    if (requireReferrerStaked) {
        // 如果推荐人已绑定，检查其绑定时的规则
        if (_hasLocked[_referrer]) {
            // 推荐人当时不需要质押，则豁免检查
            if (_userReferralRequirementSnapshot[_referrer]) {
                // 推荐人当时需要质押，则检查其当前质押状态
                if (_referrer != rootAddress && balanceOf(_referrer) <= 1 ether) {
                    revert InvalidReferrer();
                }
            }
            // 否则，推荐人获得永久豁免
        } else {
            // 推荐人未绑定（可能是rootAddress或特殊账户）
            if (_referrer != rootAddress && balanceOf(_referrer) <= 1 ether) {
                revert InvalidReferrer();
            }
        }
    }
    // 不要求质押时，无任何检查

    // ... 后续逻辑保持不变 ...
}
```

**优化后的完整逻辑**：

```solidity
function lockReferral(address _referrer) external {
    address user = msg.sender;

    if (_referrals[user] != address(0)) revert AlreadyBound();
    if (user == rootAddress) revert CannotReferSelf();

    if (_referrer == address(0)) {
        _referrer = rootAddress;
    }

    if (_referrer == user) revert CannotReferSelf();

    // ⭐ 验证推荐人资格
    _validateReferrer(_referrer);

    // ⭐ 记录快照
    _userReferralRequirementSnapshot[user] = requireReferrerStaked;

    _referrals[user] = _referrer;
    _children[_referrer].push(user);
    _hasLocked[user] = true;

    uint256 userExistingInvestment = principalBalance(user);
    if (userExistingInvestment > 0) {
        _syncExistingInvestmentToReferralChain(user, userExistingInvestment);
    }

    emit BindReferral(user, _referrer, block.number);
}

/**
 * @notice 验证推荐人资格（内部函数）
 * @param _referrer 推荐人地址
 * @dev 复杂的继承规则逻辑封装在此函数中
 */
function _validateReferrer(address _referrer) private view {
    // rootAddress 永远合法
    if (_referrer == rootAddress) {
        return;
    }

    // 当前系统不要求质押，直接通过
    if (!requireReferrerStaked) {
        return;
    }

    // 当前系统要求质押，需要检查推荐人状态
    if (_hasLocked[_referrer]) {
        // 推荐人已绑定，检查其历史快照
        if (_userReferralRequirementSnapshot[_referrer]) {
            // 推荐人当时也需要质押，检查其当前质押状态
            if (balanceOf(_referrer) <= 1 ether) {
                revert InvalidReferrer();
            }
        }
        // 推荐人当时不需要质押，永久豁免检查
    } else {
        // 推荐人未绑定（特殊情况），按当前规则检查
        if (balanceOf(_referrer) <= 1 ether) {
            revert InvalidReferrer();
        }
    }
}
```

---

## 五、测试用例设计

### 5.1 基础功能测试

```javascript
describe("推荐人质押要求配置", function() {
    it("管理员可以切换配置", async function() {
        await staking.setRequireReferrerStaked(true);
        expect(await staking.requireReferrerStaked()).to.equal(true);

        await staking.setRequireReferrerStaked(false);
        expect(await staking.requireReferrerStaked()).to.equal(false);
    });

    it("非管理员无法切换配置", async function() {
        await expect(
            staking.connect(user1).setRequireReferrerStaked(true)
        ).to.be.revertedWith("Ownable: caller is not the owner");
    });
});
```

### 5.2 绑定规则测试

```javascript
describe("推荐人绑定规则", function() {
    it("强制质押模式：未质押推荐人被拒绝", async function() {
        await staking.setRequireReferrerStaked(true);

        // user1 未质押
        await expect(
            staking.connect(user2).lockReferral(user1.address)
        ).to.be.revertedWithCustomError(staking, "InvalidReferrer");
    });

    it("强制质押模式：已质押推荐人可以绑定", async function() {
        await staking.setRequireReferrerStaked(true);

        // user1 质押 > 1 SYI
        await staking.connect(user1).stake(1000, 0);

        // user2 绑定 user1
        await staking.connect(user2).lockReferral(user1.address);
        expect(await staking.getReferral(user2.address)).to.equal(user1.address);
    });

    it("非强制模式：未质押推荐人可以绑定", async function() {
        await staking.setRequireReferrerStaked(false);

        // user1 未质押
        await staking.connect(user2).lockReferral(user1.address);
        expect(await staking.getReferral(user2.address)).to.equal(user1.address);
    });
});
```

### 5.3 快照继承测试

```javascript
describe("规则快照继承", function() {
    it("宽松模式绑定的用户，获得永久豁免权", async function() {
        // 阶段1: 宽松模式
        await staking.setRequireReferrerStaked(false);
        await staking.connect(user1).lockReferral(rootAddress);

        // user1 不质押
        expect(await staking.balanceOf(user1.address)).to.equal(0);

        // 阶段2: 切换到严格模式
        await staking.setRequireReferrerStaked(true);

        // 阶段3: user2 仍然可以绑定 user1（user1 有豁免权）
        await staking.connect(user2).lockReferral(user1.address);
        expect(await staking.getReferral(user2.address)).to.equal(user1.address);
    });

    it("严格模式绑定的用户，质押后才能推荐", async function() {
        // 阶段1: 严格模式
        await staking.setRequireReferrerStaked(true);
        await staking.connect(user1).stake(1000, 0); // user1 质押
        await staking.connect(user1).lockReferral(rootAddress);

        // 阶段2: 切换到宽松模式
        await staking.setRequireReferrerStaked(false);

        // 阶段3: user1 unstake 后质押为 0
        await time.increase(86400 * 30);
        await staking.connect(user1).unstake(0);

        // 阶段4: 切回严格模式
        await staking.setRequireReferrerStaked(true);

        // 阶段5: user2 无法绑定 user1（user1 质押为 0）
        await expect(
            staking.connect(user2).lockReferral(user1.address)
        ).to.be.revertedWithCustomError(staking, "InvalidReferrer");
    });
});
```

### 5.4 多层级传递测试

```javascript
describe("豁免权多层级传递", function() {
    it("宽松模式建立的推荐链，永久有效", async function() {
        // 阶段1: 宽松模式建立三层推荐链
        await staking.setRequireReferrerStaked(false);
        await staking.connect(user1).lockReferral(rootAddress);
        await staking.connect(user2).lockReferral(user1.address);
        await staking.connect(user3).lockReferral(user2.address);

        // 无人质押
        expect(await staking.balanceOf(user1.address)).to.equal(0);
        expect(await staking.balanceOf(user2.address)).to.equal(0);
        expect(await staking.balanceOf(user3.address)).to.equal(0);

        // 阶段2: 切换到严格模式
        await staking.setRequireReferrerStaked(true);

        // 阶段3: user4 仍然可以绑定 user3（继承豁免权）
        await staking.connect(user4).lockReferral(user3.address);
        expect(await staking.getReferral(user4.address)).to.equal(user3.address);
    });
});
```

---

## 六、部署和升级策略

### 6.1 新合约部署
- 构造函数中默认 `requireReferrerStaked = true`（保持原有严格行为）
- 管理员可根据运营需求调用 `setRequireReferrerStaked(false)` 放宽限制

### 6.2 已部署合约升级（如需）
- **不可升级**：当前合约没有代理模式，无法直接升级
- **迁移方案**：
  1. 部署新合约（包含本方案修改）
  2. 迁移用户数据（推荐关系、质押记录）
  3. 所有已绑定用户的快照默认设置为 `true`（继承原有严格规则）

---

## 七、Gas 成本分析

### 新增存储成本
- `requireReferrerStaked`：1 个 `bool`（约 20,000 gas 首次写入）
- `_userReferralRequirementSnapshot`：每个用户 1 个 `bool`（约 20,000 gas 每次绑定）

### 函数调用成本变化
- `lockReferral()`：
  - 增加 1 次 `SSTORE`（保存快照）：+20,000 gas（首次） / +5,000 gas（后续）
  - 增加 1-2 次 `SLOAD`（读取快照）：+2,100 gas
  - **总计**：+22,100 gas（首次） / +7,100 gas（后续）

### 优化建议
- 使用 `packed storage`：将 `requireReferrerStaked` 和其他 `bool` 打包到同一槽位
- 考虑使用 `bitmap` 存储用户快照（如果用户量极大）

---

## 八、安全性考虑

### 8.1 潜在风险
1. **管理员权限滥用**：
   - 风险：管理员频繁切换配置，导致用户混淆
   - 缓解：建议使用 Timelock 合约控制配置变更

2. **快照数据篡改**：
   - 风险：`_userReferralRequirementSnapshot` 被恶意修改
   - 缓解：映射为 `private`，仅通过 `lockReferral` 写入

3. **规则绕过**：
   - 风险：用户在宽松模式绑定，切换到严格模式后获得不当优势
   - 缓解：**这是设计目标**，合理利用系统规则，不属于漏洞

### 8.2 审计检查点
- ✅ 检查 `_validateReferrer()` 逻辑完整性
- ✅ 检查 `lockReferral()` 的 reentrancy 风险（已有 `onlyEOA` 保护）
- ✅ 检查 `setRequireReferrerStaked()` 的权限控制
- ✅ 检查快照数据的不可篡改性

---

## 九、向后兼容性

### 9.1 对前端的影响
需要新增以下接口调用：
```javascript
// 查询当前系统配置
const requireStaked = await staking.requireReferrerStaked();

// 查询用户绑定时的规则
const { wasRequired, hasLocked } = await staking.getUserReferralRequirement(userAddress);

// 查询某人能否成为推荐人
const { canRefer, reason } = await staking.canBeReferrer(potentialReferrerAddress);
```

### 9.2 对事件监听的影响
新增事件：
```javascript
staking.on("ReferrerStakeRequirementUpdated", (oldValue, newValue, timestamp) => {
    console.log(`推荐人质押要求变更: ${oldValue} -> ${newValue}`);
});
```

---

## 十、总结

### 优点
✅ **灵活性**：管理员可根据运营阶段动态调整规则
✅ **公平性**：用户绑定时的规则永久生效，不受后续变更影响
✅ **向后兼容**：不影响已绑定用户，平滑过渡
✅ **可审计**：完整的事件日志和查询接口

### 缺点
⚠️ **复杂性增加**：验证逻辑从简单判断变为多层条件嵌套
⚠️ **Gas 成本**：每次绑定额外消耗约 20,000 gas
⚠️ **测试成本**：需要覆盖多种时序组合的测试用例

### 建议
1. **优先级**：如果项目处于初期，建议直接部署修改后的合约
2. **运营策略**：
   - 启动初期：`requireReferrerStaked = false`（快速扩张）
   - 稳定期：`requireReferrerStaked = true`（提高门槛）
3. **文档化**：在白皮书中明确说明规则变更机制，避免用户误解

---

## 十一、实施检查清单

- [ ] 在 `StakingBase.sol` 添加状态变量
- [ ] 在 `IStaking.sol` 添加事件定义
- [ ] 实现 `setRequireReferrerStaked()` 函数
- [ ] 实现 `_validateReferrer()` 内部函数
- [ ] 修改 `lockReferral()` 函数逻辑
- [ ] 实现查询函数（可选）
- [ ] 编写完整测试用例（至少覆盖 5.1-5.4）
- [ ] 进行 Gas 成本测试
- [ ] 通过安全审计
- [ ] 更新前端接口文档
- [ ] 部署到测试网验证
- [ ] 主网部署并公告规则

---

**文档版本**: v1.0
**创建日期**: 2025-10-20
**作者**: SYI Protocol Team
**审核状态**: 待技术评审
