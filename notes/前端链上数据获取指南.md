# 前端链上数据获取指南

本文档列出所有可通过前端直接调用的合约只读函数（view/pure），用于获取用户信息和系统状态。

## 目录

1. [Staking 质押合约](#staking-质押合约)
   - [用户基本信息](#1-用户基本信息)
   - [质押记录信息](#2-质押记录信息)
   - [提现历史](#3-提现历史)
   - [推荐关系](#4-推荐关系)
   - [团队信息](#5-团队信息)
   - [系统配置](#6-系统配置)
   - [网络活动](#7-网络活动)
   - [公共信息](#8-公共信息)
2. [SYI 代币合约](#syi-代币合约)

---

## Staking 质押合约

合约位置：`contracts/SYI-Staking/abstract/StakingBase.sol`

### 1. 用户基本信息

#### `getUserInfo(address user)`
**返回值：**
```solidity
(
    uint128 totalStaked,         // 总质押价值（含收益）
    uint128 teamKPI,              // 团队KPI
    address referrer,             // 推荐人地址
    bool hasLockedReferral,       // 是否已绑定推荐人
    bool isPreacherStatus         // 是否为 preacher（≥200 SYI）
)
```
**说明：** 一次性获取用户核心信息，适合个人中心页面

**示例：**
```javascript
const userInfo = await stakingContract.getUserInfo(userAddress);
console.log('总质押:', ethers.formatEther(userInfo.totalStaked), 'SYI');
console.log('团队KPI:', ethers.formatEther(userInfo.teamKPI), 'USDT');
console.log('推荐人:', userInfo.referrer);
console.log('是否Preacher:', userInfo.isPreacherStatus);
```

---

#### `balanceOf(address account)`
**返回值：** `uint256` - 当前质押总价值（本金 + 收益）

**说明：** 返回用户所有未解除质押的当前总价值，按复利实时计算

---

#### `principalBalance(address account)`
**返回值：** `uint256` - 质押本金总额

**说明：** 返回用户质押的原始本金总和（不含收益）

---

#### `earnedInterest(address account)`
**返回值：** `uint256` - 已赚取利息

**计算公式：** `earnedInterest = balanceOf(account) - principalBalance(account)`

---

#### `stakeCount(address user)`
**返回值：** `uint256` - 质押记录数量

**说明：** 返回用户创建的质押记录总数（包含已解除的）

---

### 2. 质押记录信息

#### `userStakeRecord(address user, uint256 index)`
**返回值：**
```solidity
(
    uint40 stakeTime,      // 质押时间戳
    uint160 amount,        // 质押金额
    bool status,           // 是否已解除（true=已解除, false=活跃）
    uint8 stakeIndex       // 质押档位（0=1天, 1=30天, 2=90天, 3=180天）
)
```
**说明：** 获取特定索引的质押记录

**示例：**
```javascript
// 获取用户所有质押记录
const count = await stakingContract.stakeCount(userAddress);
for (let i = 0; i < count; i++) {
    const record = await stakingContract.userStakeRecord(userAddress, i);
    if (!record.status) { // 仅显示活跃质押
        console.log(`质押#${i}:`, {
            amount: ethers.formatEther(record.amount),
            stakeTime: new Date(record.stakeTime * 1000),
            period: ['1天', '30天', '90天', '180天'][record.stakeIndex]
        });
    }
}
```

---

#### `rewardOfSlot(address user, uint8 index)`
**返回值：** `uint256` - 当前奖励金额（包含本金）

**说明：** 返回指定质押位的当前价值（本金 + 复利收益）

**注意：** 返回值包含本金，纯收益需减去本金

---

#### `canWithdrawStake(address user, uint256 stakeIndex)`
**返回值：** `bool` - 是否可以解除质押

**判断条件：**
1. 质押记录存在
2. 未被解除（status=false）
3. 已达到锁定期

---

#### `getUserStakeWithdrawalStatus(address user)`
**返回值：**
```solidity
(
    uint256[] stakeIndices,        // 质押索引列表
    bool[] canWithdrawArray,       // 是否可解除列表
    uint256[] timeRemaining        // 剩余锁定时间（秒）
)
```
**说明：** 批量获取所有质押的解锁状态

**示例：**
```javascript
const status = await stakingContract.getUserStakeWithdrawalStatus(userAddress);
status.stakeIndices.forEach((idx, i) => {
    console.log(`质押#${idx}:`, {
        canWithdraw: status.canWithdrawArray[i],
        remainingTime: status.timeRemaining[i].toString() + '秒'
    });
});
```

---

### 3. 提现历史

#### `getWithdrawalHistory(address user)`
**返回值：** `WithdrawalRecord[]` - 完整提现历史

**WithdrawalRecord 结构：**
```solidity
struct WithdrawalRecord {
    uint40 withdrawalTime;      // 提现时间
    uint256 stakeIndex;         // 质押索引
    uint256 principalAmount;    // 本金金额
    uint256 calculatedReward;   // 计算的奖励（SYI）
    uint256 usdtReceived;       // 收到的USDT总额
    uint256 syiTokensUsed;      // 使用的SYI代币
    uint256 referralFee;        // 推荐人费用（5%）
    uint256 teamFee;            // 团队费用（最高35%）
    uint256 userPayout;         // 用户实际到账
    uint256 interestEarned;     // 利息收益
}
```

**示例：**
```javascript
const history = await stakingContract.getWithdrawalHistory(userAddress);
history.forEach((record, i) => {
    console.log(`提现#${i}:`, {
        time: new Date(record.withdrawalTime * 1000),
        principal: ethers.formatEther(record.principalAmount),
        interest: ethers.formatEther(record.interestEarned),
        payout: ethers.formatEther(record.userPayout)
    });
});
```

---

#### `getWithdrawalCount(address user)`
**返回值：** `uint256` - 提现次数

---

#### `getWithdrawalRecord(address user, uint256 index)`
**返回值：** `WithdrawalRecord` - 单条提现记录

---

### 4. 推荐关系

#### `getReferral(address user)`
**返回值：** `address` - 直接推荐人（上级）

**说明：** 返回 `address(0)` 表示未绑定或绑定到root

---

#### `getReferrals(address user, uint256 maxDepth)`
**返回值：** `address[]` - 推荐链（多级上级）

**参数：**
- `maxDepth`: 最大查询深度（建议30）

**说明：** 返回从直接上级开始的推荐链，按距离升序排列

**示例：**
```javascript
const chain = await stakingContract.getReferrals(userAddress, 30);
console.log('推荐链路:', chain);
// [直接上级, 二级上级, 三级上级, ...]
```

---

#### `isBindReferral(address user)`
**返回值：** `bool` - 是否已绑定推荐人

---

#### `getReferralCount(address user)`
**返回值：** `uint256` - 直推人数

**说明：** 返回该地址的直接下级数量

---

#### `getFriend(address user)`
**返回值：** `address` - 好友地址（直推5%收款地址）

**说明：**
- 返回接收直推5%奖励的地址
- 如果未绑定好友，返回 `address(0)`，奖励将发给root
- 好友机制与推荐树独立

---

### 5. 团队信息

#### `getTeamKpi(address user)`
**返回值：** `uint256` - 团队KPI（团队总投资额，USDT计价）

**说明：** 用于判断用户的团队等级（V1-V7）

---

#### `getTeamPerformanceDetails(address user)`
**返回值：**
```solidity
(
    uint256 totalTeamInvestment,    // 团队总投资
    uint256 teamMemberCount,        // 团队成员数（直推数）
    uint8 currentTier,              // 当前等级（0-7）
    uint256 nextTierThreshold,      // 下一等级门槛
    uint256 progressToNextTier      // 升级进度（百分比）
)
```

**等级对应关系：**
- 0: 无等级
- 1: V1 (10,000 USDT, 5%奖励)
- 2: V2 (50,000 USDT, 10%奖励)
- 3: V3 (200,000 USDT, 15%奖励)
- 4: V4 (500,000 USDT, 20%奖励)
- 5: V5 (1,000,000 USDT, 25%奖励)
- 6: V6 (2,500,000 USDT, 30%奖励)
- 7: V7 (5,000,000 USDT, 35%奖励)

**示例：**
```javascript
const details = await stakingContract.getTeamPerformanceDetails(userAddress);
console.log('团队详情:', {
    totalInvestment: ethers.formatEther(details.totalTeamInvestment),
    memberCount: details.teamMemberCount.toString(),
    tier: `V${details.currentTier}`,
    progress: details.progressToNextTier.toString() + '%'
});
```

---

#### `isPreacher(address user)`
**返回值：** `bool` - 是否为 preacher

**条件：** 当前质押价值 ≥ 200 SYI

**说明：** Preacher 是领取团队奖励的前提条件

---

#### `teamTotalInvestValue(address user)`
**返回值：** `uint256` - 团队总投资价值（public mapping）

**说明：** 与 `getTeamKpi()` 返回相同值

---

### 6. 系统配置

#### `getStakePeriod(uint8 stakeIndex)`
**返回值：** `uint256` - 质押周期（秒）

**参数：**
- `stakeIndex`: 0=1天, 1=30天, 2=90天, 3=180天

**注意：** 测试网为秒级，主网为实际天数

---

#### `getStakePeriods()`
**返回值：** `uint256[4]` - 所有质押周期

---

#### `rates(uint256 index)`
**返回值：** `uint256` - APY 利率（1e18 精度）

**说明：**
- `rates[0]` = 0.3% 日利率 → 1.003e18
- `rates[1]` = 0.6% 日利率 → 1.006e18
- `rates[2]` = 0.9% 日利率 → 1.009e18
- `rates[3]` = 1.5% 日利率 → 1.015e18

---

#### `getTeamRewardThresholds()`
**返回值：** `uint256[7]` - 团队奖励门槛（USDT）

**返回示例：** `[5,000,000, 2,500,000, 1,000,000, 500,000, 200,000, 50,000, 10,000]`

---

#### `getTeamRewardRates()`
**返回值：** `uint256[7]` - 团队奖励比例（百分比）

**返回示例：** `[35, 30, 25, 20, 15, 10, 5]`

---

#### `getSlippageConfig()`
**返回值：**
```solidity
(
    uint256 baseSlippage,              // 基础滑点（1500 = 15%）
    uint256 maxSlippage,               // 最大滑点（2000 = 20%）
    uint256 priceImpactThreshold       // 价格影响阈值（200 = 2%）
)
```

---

#### `getMaxStakeAmount()`
**返回值：** `uint256` - 当前最大单笔质押金额

**限制条件：**
1. 不超过池子USDT储备的1%
2. 不超过 1000 USDT
3. 根据近期网络流入动态调整

---

#### `getRemainingStakeCapacity(address user)`
**返回值：** `uint256` - 用户剩余可质押额度

**说明：** 每个用户总质押限额为 10,000 USDT

---

#### `getMaxUserTotalStake()`
**返回值：** `uint256` - 用户最大总质押限制

**固定值：** 10,000 USDT

---

### 7. 网络活动

#### `getNetworkInflow()` / `network1In()`
**返回值：** `uint256` - 近期网络流入（1分钟内）

**说明：** 用于动态调整最大质押金额

---

#### `getRecentNetworkInflow()`
**返回值：** `uint256` - 近期网络流入

**说明：** 与上述函数相同

---

#### `maxStakeAmount()`
**返回值：** `uint256` - 最大质押金额

**说明：** 与 `getMaxStakeAmount()` 相同

---

#### `previewStakeOutput(uint256 usdtAmount)`
**返回值：**
```solidity
(
    uint256 halfUsdtAmount,    // 用于购买SYI的USDT数量（一半）
    uint256 expectedSYI,       // 预期获得的SYI数量
    uint256 minSYIOut          // 最小接受的SYI数量（滑点保护）
)
```

**说明：** 预览质押时USDT如何分配及预期收到的SYI数量

---

### 8. 公共信息

#### `totalSupply()`
**返回值：** `uint256` - sSYI 总供应量

**说明：** 等于所有用户当前未解除质押的本金总和

---

#### `name()`
**返回值：** `string` - "Staked SYI"

---

#### `symbol()`
**返回值：** `string` - "sSYI"

---

#### `decimals()`
**返回值：** `uint8` - 18

---

#### `getRootAddress()`
**返回值：** `address` - root 地址（默认推荐人）

---

#### `SYI()`
**返回值：** `address` - SYI 代币合约地址

---

#### `ROUTER()`
**返回值：** `address` - Uniswap V2 Router 地址

---

#### `USDT()`
**返回值：** `address` - USDT 代币地址

---

#### `feeRecipient()`
**返回值：** `address` - 赎回费用接收地址（1%）

---

## SYI 代币合约

合约位置：`contracts/SYI/abstract/SYIBase.sol`

### 1. 代币基本信息

#### `name()`
**返回值：** `string` - "SYI Token"

---

#### `symbol()`
**返回值：** `string` - "SYI"

---

#### `decimals()`
**返回值：** `uint8` - 18

---

#### `totalSupply()`
**返回值：** `uint256` - 总供应量

**固定值：** 100,000,000 SYI

---

#### `balanceOf(address account)`
**返回值：** `uint256` - 账户SYI余额

---

### 2. 交易相关

#### `getUniswapV2Pair()`
**返回值：** `address` - SYI/USDT 交易对地址

---

#### `getUSDTReserve()`
**返回值：** `uint112` - 流动性池中的USDT储备量

**说明：** 用于计算价格和滑点

---

#### `getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)`
**返回值：** `uint256` - 输出代币数量

**说明：** AMM 计算函数（x * y = k）

---

#### `getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)`
**返回值：** `uint256` - 需要的输入代币数量

**说明：** AMM 反向计算函数

---

### 3. 预售信息

#### `getPresaleStatus()`
**返回值：**
```solidity
(
    bool active,              // 预售是否激活
    uint256 startTime,        // 预售开始时间
    uint256 duration,         // 预售持续时长
    uint256 remainingTime,    // 剩余时间
    bool isInPresale          // 当前是否在预售期
)
```

---

#### `presaleActive()`
**返回值：** `bool` - 预售是否激活

---

#### `presaleStartTime()`
**返回值：** `uint256` - 预售开始时间戳

---

#### `presaleDuration()`
**返回值：** `uint256` - 预售持续时间（秒）

**默认值：** 30天（主网）

---

### 4. 延迟购买信息

#### `getDelayedBuyInfo()`
**返回值：**
```solidity
(
    bool enabled,              // 是否启用延迟购买
    bool testModeActive,       // 测试模式（已废弃，固定false）
    uint256 enabledTime,       // 启用时间
    uint256 requiredDelay,     // 需要的延迟时长
    uint256 remainingDelay     // 剩余延迟时间
)
```

---

#### `isDelayedBuyPeriodMet(address buyer)`
**返回值：** `bool` - 买家是否满足延迟购买期

**说明：** 白名单用户始终返回 `true`

---

#### `delayedBuyEnabled()`
**返回值：** `bool` - 延迟购买是否启用

---

### 5. 账户状态

#### `feeWhitelisted(address account)`
**返回值：** `bool` - 是否在费用白名单中

**白名单特权：**
- 无买卖手续费
- 无延迟购买限制
- 无盈利税

---

#### `blacklisted(address account)`
**返回值：** `bool` - 是否被拉黑

**说明：** 黑名单地址无法进行买卖操作

---

#### `lastBuyTime(address account)`
**返回值：** `uint256` - 最后购买时间戳

**说明：** 用于冷却期检查（卖出需等待 `coldTime`）

---

#### `coldTime()`
**返回值：** `uint256` - 冷却时间（秒）

**默认值：** 10秒

---

### 6. 工具函数

#### `isContract(address account)`
**返回值：** `bool` - 地址是否为合约

**说明：** 通过 `extcodesize` 判断

---

## 按月查询每日收益的实现方案

由于合约没有提供按月查询每日收益的直接函数，需要前端通过以下方式实现：

### 方案1：基于质押记录计算（推荐）

```javascript
/**
 * 计算某个质押记录在指定时间范围内的每日收益
 * @param {Object} stakeRecord - 质押记录
 * @param {number} startTimestamp - 开始时间戳
 * @param {number} endTimestamp - 结束时间戳
 */
function calculateDailyEarnings(stakeRecord, startTimestamp, endTimestamp) {
    const { amount, stakeTime, stakeIndex, status } = stakeRecord;

    // APY利率（从合约获取）
    const rates = [
        1.003, // 0.3% daily
        1.006, // 0.6% daily
        1.009, // 0.9% daily
        1.015  // 1.5% daily
    ];
    const dailyRate = rates[stakeIndex];

    // 计算有效时间范围
    const effectiveStart = Math.max(stakeTime, startTimestamp);
    const effectiveEnd = status ? Math.min(stakeRecord.withdrawalTime, endTimestamp) : endTimestamp;

    const dailyEarnings = [];
    let currentValue = amount;

    for (let day = effectiveStart; day <= effectiveEnd; day += 86400) {
        const previousValue = currentValue;
        currentValue = previousValue * dailyRate;
        const dailyProfit = currentValue - previousValue;

        dailyEarnings.push({
            date: new Date(day * 1000).toISOString().split('T')[0],
            principal: ethers.formatEther(amount),
            currentValue: ethers.formatEther(currentValue),
            dailyProfit: ethers.formatEther(dailyProfit),
            cumulativeProfit: ethers.formatEther(currentValue - amount)
        });
    }

    return dailyEarnings;
}
```

### 方案2：监听事件（历史数据）

通过监听 `Staked` 和 `RewardPaid` 事件构建完整历史记录：

```javascript
// 获取质押事件
const stakedEvents = await stakingContract.queryFilter(
    stakingContract.filters.Staked(userAddress),
    fromBlock,
    toBlock
);

// 获取提现事件
const withdrawalEvents = await stakingContract.queryFilter(
    stakingContract.filters.WithdrawalCompleted(userAddress),
    fromBlock,
    toBlock
);
```

---

## 完整前端示例代码

```javascript
import { ethers } from 'ethers';

// 初始化合约实例
const provider = new ethers.JsonRpcProvider('https://bsc-dataseed1.binance.org/');
const stakingAddress = '0x...'; // Staking合约地址
const syiAddress = '0x...';     // SYI合约地址

const stakingContract = new ethers.Contract(stakingAddress, STAKING_ABI, provider);
const syiContract = new ethers.Contract(syiAddress, SYI_ABI, provider);

// 获取用户完整信息
async function getUserFullInfo(userAddress) {
    const [
        userInfo,
        stakeCount,
        referralCount,
        withdrawalCount,
        syiBalance,
        teamDetails
    ] = await Promise.all([
        stakingContract.getUserInfo(userAddress),
        stakingContract.stakeCount(userAddress),
        stakingContract.getReferralCount(userAddress),
        stakingContract.getWithdrawalCount(userAddress),
        syiContract.balanceOf(userAddress),
        stakingContract.getTeamPerformanceDetails(userAddress)
    ]);

    return {
        // 基本信息
        totalStaked: ethers.formatEther(userInfo.totalStaked),
        teamKPI: ethers.formatEther(userInfo.teamKPI),
        referrer: userInfo.referrer,
        hasLockedReferral: userInfo.hasLockedReferral,
        isPreacher: userInfo.isPreacherStatus,

        // 质押统计
        stakeCount: stakeCount.toString(),
        withdrawalCount: withdrawalCount.toString(),

        // 推荐统计
        referralCount: referralCount.toString(),

        // 代币余额
        syiBalance: ethers.formatEther(syiBalance),

        // 团队详情
        teamMemberCount: teamDetails.teamMemberCount.toString(),
        currentTier: teamDetails.currentTier,
        progressToNextTier: teamDetails.progressToNextTier.toString()
    };
}

// 获取所有质押记录及状态
async function getAllStakes(userAddress) {
    const count = await stakingContract.stakeCount(userAddress);
    const stakes = [];

    for (let i = 0; i < count; i++) {
        const [record, currentReward, canWithdraw] = await Promise.all([
            stakingContract.userStakeRecord(userAddress, i),
            stakingContract.rewardOfSlot(userAddress, i),
            stakingContract.canWithdrawStake(userAddress, i)
        ]);

        stakes.push({
            index: i,
            amount: ethers.formatEther(record.amount),
            stakeTime: new Date(record.stakeTime * 1000),
            period: ['1天', '30天', '90天', '180天'][record.stakeIndex],
            status: record.status ? '已解除' : '活跃',
            currentReward: ethers.formatEther(currentReward),
            canWithdraw
        });
    }

    return stakes;
}

// 获取下级列表（需要遍历）
async function getDirectReferrals(userAddress) {
    const count = await stakingContract.getReferralCount(userAddress);
    // 注意：合约没有提供直接获取下级列表的函数
    // 需要通过监听 BindReferral 事件获取
    const bindEvents = await stakingContract.queryFilter(
        stakingContract.filters.BindReferral(null, userAddress)
    );

    return bindEvents.map(event => ({
        referral: event.args.user,
        blockNumber: event.blockNumber,
        timestamp: event.args.timestamp
    }));
}

// 使用示例
const userAddress = '0x...';
const fullInfo = await getUserFullInfo(userAddress);
const stakes = await getAllStakes(userAddress);
const referrals = await getDirectReferrals(userAddress);

console.log('用户信息:', fullInfo);
console.log('质押列表:', stakes);
console.log('下级列表:', referrals);
```

---

## 重要提示

### 1. 数据一致性
- `balanceOf()` 返回当前价值（含收益），实时计算
- `principalBalance()` 返回本金，固定值
- 两者差值为已赚取利息

### 2. 团队奖励机制
- **直推5%** → 发给 `friend` 地址（未绑定则发root）
- **团队0-35%** → 发给推荐链上符合条件的上级（差额奖励）
- 领取团队奖励需要：
  1. 是 preacher（≥200 SYI）
  2. 达到对应团队KPI门槛
  3. 在推荐链上首个达到该等级的人

### 3. 下级列表获取
合约未提供直接获取下级列表的函数，需通过以下方式：
- 监听 `BindReferral(address indexed user, address indexed referrer)` 事件
- 筛选 `referrer == 目标地址` 的事件
- 提取 `user` 字段作为下级列表

### 4. 时间单位
- **主网（生产环境）：** 按天计算（1 days）
- **测试网：** 按秒计算（1 second）
- 调用 `getStakePeriod()` 获取实际值

### 5. 精度处理
- 所有金额使用 18 位精度（wei）
- 前端显示需除以 1e18 或使用 `ethers.formatEther()`

---

## 常见问题

### Q: 如何获取用户的历史收益曲线？
A: 通过 `WithdrawalCompleted` 事件或本文档"按月查询每日收益"方案

### Q: 如何判断用户是否可以领取团队奖励？
A:
1. `isPreacher(user)` 返回 `true`
2. `getTeamPerformanceDetails()` 查看 `currentTier > 0`

### Q: 如何获取用户的所有上级？
A: `getReferrals(userAddress, 30)` 返回最多30层上级

### Q: 如何查询用户何时可以解除质押？
A: `getUserStakeWithdrawalStatus()` 返回所有质押的剩余锁定时间

---

## 相关文档

- [合约架构说明](../CLAUDE.md)
- [质押机制详解](./质押机制详解.md)
- [推荐系统说明](./推荐系统说明.md)

---

**文档版本：** v1.0
**最后更新：** 2025-10-14
**合约版本：** Solidity 0.8.20
