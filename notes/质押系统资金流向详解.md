# 质押系统资金流向详解

## 目录
1. [系统概览](#系统概览)
2. [质押流程 (stake)](#质押流程-stake)
3. [提前提取利息 (withdrawInterest)](#提前提取利息-withdrawinterest)
4. [解质押流程 (unstake)](#解质押流程-unstake)
5. [奖励分配机制](#奖励分配机制)
6. [复利计算机制](#复利计算机制)
7. [关键常量与费率](#关键常量与费率)

---

## 系统概览

### 核心合约
- **Staking 合约**: `contracts/SYI-Staking/mainnet/Staking.sol`
- **StakingBase 基类**: `contracts/SYI-Staking/abstract/StakingBase.sol`
- **SYI 代币**: `contracts/SYI/mainnet/SYI.sol`

### 整体资金循环图

```
┌─────────────────────────────────────────────────────────────────┐
│                     SYI 质押系统资金循环                           │
└─────────────────────────────────────────────────────────────────┘

     用户 USDT
         │
         │ 1. stake()
         ↓
   ┌──────────────┐
   │   Staking    │
   │   合约       │
   └──────────────┘
         │
         ├─────→ 50% USDT ──→ Swap 为 SYI
         │                       │
         └─────→ 50% USDT ──────┤
                                 │
                                 ↓
                      ┌──────────────────┐
                      │  添加流动性池     │
                      │  (SYI/USDT Pair) │
                      │  LP 代币销毁     │
                      └──────────────────┘
                                 │
                      ┌──────────┴──────────┐
                      │                     │
                      ↓                     ↓
              交易手续费累积          价格稳定支撑
                      │
                      │ 2. unstake/withdrawInterest
                      ↓
              ┌──────────────────┐
              │  从池子取出 SYI   │
              │  (recycle 机制)  │
              └──────────────────┘
                      │
                      │ 3. Swap SYI → USDT
                      ↓
              ┌──────────────────┐
              │   奖励分配        │
              ├──────────────────┤
              │ • 用户收益        │
              │ • Friend 5%      │
              │ • Team 最高35%   │
              │ • Redemption 1%  │
              └──────────────────┘
```

---

## 质押流程 (stake)

### 函数入口
```solidity
function stake(uint160 _amount, uint8 _stakeIndex) external onlyEOA
```
**位置**: `StakingBase.sol:270`

### 详细流程

```
┌────────────────────────────────────────────────────────────────┐
│                        质押流程                                 │
└────────────────────────────────────────────────────────────────┘

用户调用 stake(1000 USDT, stakeIndex=1)
    │
    ├─ 步骤1: _validateStakeParameters()
    │    ├─ 检查是否超过单次最大质押额 (MAX_STAKE_LIMIT = 1000 SYI)
    │    ├─ 检查质押索引是否有效 (0-3)
    │    └─ 检查用户总质押是否超限 (MAX_USER_TOTAL_STAKE = 10000 SYI)
    │
    ├─ 步骤2: _swapAndAddLiquidity(1000 USDT) ⭐ 核心资金流
    │    │
    │    ├─ 2.1 转入 USDT
    │    │    USDT.transferFrom(用户, Staking合约, 1000 USDT)
    │    │
    │    ├─ 2.2 分割 USDT
    │    │    usdtToSwap = 1000 / 2 = 500 USDT
    │    │    remainingUsdt = 500 USDT
    │    │
    │    ├─ 2.3 兑换 SYI (line 1502-1508)
    │    │    Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
    │    │        500 USDT,           // 投入金额
    │    │        minOlaTokensOut,    // 最小输出（滑点保护）
    │    │        [USDT, SYI],       // 交易路径
    │    │        Staking合约,        // 接收地址
    │    │        deadline
    │    │    )
    │    │    结果: 获得约 X 个 SYI (取决于池子价格)
    │    │
    │    └─ 2.4 添加流动性 (line 1514-1523)
    │         Router.addLiquidity(
    │             USDT,              // 代币A
    │             SYI,               // 代币B
    │             500 USDT,          // USDT 数量
    │             X SYI,             // SYI 数量
    │             0,                 // 最小 USDT (无限制)
    │             0,                 // 最小 SYI (无限制)
    │             address(0),        // ⚠️ LP 代币发送到黑洞地址（销毁）
    │             deadline
    │         )
    │
    └─ 步骤3: _mintStakeRecord() (line 1136-1174)
         ├─ 检查用户是否绑定推荐人 (必须绑定)
         ├─ 记录网络总供应量快照
         ├─ 创建质押记录
         │    Record {
         │        startTime: 当前时间戳,          // 原始质押时间
         │        stakeTime: 当前时间戳,          // 复利计算起点
         │        originalEndTime: 当前 + 期限,   // 到期时间
         │        amount: 1000 USDT,             // 本金
         │        totalWithdrawn: 0,             // 累计提取
         │        status: false,                 // 未解质押
         │        stakeIndex: 1                  // 30天档位
         │    }
         ├─ 更新团队投资值 (向上传播)
         ├─ 铸造 sSYI (Staked SYI)
         │    _update(address(0), 用户, 1000)
         │    totalSupply += 1000
         │    balances[用户] += 1000
         └─ 发出事件 Staked(用户, 1000, 时间戳, 索引, 期限)
```

### 资金流向图

```
用户钱包 (1000 USDT)
     │
     │ transferFrom
     ↓
Staking 合约 (1000 USDT)
     │
     ├───────────────────┬────────────────────┐
     │                   │                    │
     ↓                   ↓                    ↓
  500 USDT         500 USDT          铸造 sSYI
     │                   │               (记账代币)
     │ Swap              │                    │
     ↓                   │                    ↓
  X SYI ────────────┬───┘              用户余额 +1000
     │              │
     │              │
     ↓              ↓
 添加流动性 (X SYI + 500 USDT)
     │
     ├─→ SYI/USDT Pair (流动性池增加)
     └─→ LP 代币 → address(0) (永久销毁)
```

### 关键点说明

1. **LP 代币销毁** (line 1521)
   - `address(0)` 作为 LP 接收地址
   - 这意味着流动性**永久锁定**，无法撤回
   - 保证池子深度只增不减

2. **滑点保护** (line 1500)
   - `_calculateMinimumOutput()` 计算最小输出
   - 基础滑点: 15% (BASE_SLIPPAGE_TOLERANCE = 1500)
   - 最大滑点: 20% (MAX_SLIPPAGE_TOLERANCE = 2000)

3. **质押档位** (Staking.sol:27-41)
   ```
   stakeIndex  |  日利率  |  期限      |  总收益 (复利)
   -----------|---------|-----------|------------------
       0      |  0.3%   |  1 天     |  约 0.3%
       1      |  0.6%   |  30 天    |  约 19.7%
       2      |  0.9%   |  90 天    |  约 125%
       3      |  1.5%   |  180 天   |  约 1379%
   ```

---

## 提前提取利息 (withdrawInterest)

### 函数入口
```solidity
function withdrawInterest(uint256 stakeIndex) external onlyEOA
    returns (uint256 profitWithdrawn)
```
**位置**: `StakingBase.sol:283`

### 核心概念
**允许用户提前提取收益，但保留本金继续质押**
- ✅ 提取已产生的利息
- ✅ 本金保持质押
- ✅ 到期时间不变
- ⚠️ 复利起点重置为当前时间

### 详细流程

```
┌────────────────────────────────────────────────────────────────┐
│                    提前提取利息流程                              │
└────────────────────────────────────────────────────────────────┘

用户: 质押了 1000 USDT，30天期限，已过 10 天
    │
    ├─ 步骤1: 验证条件 (line 290-294)
    │    ├─ require(!stakeRecord.status) - 未解质押
    │    └─ require(block.timestamp < originalEndTime) - 未到期
    │
    ├─ 步骤2: 计算当前价值 (line 296)
    │    currentValue = _calculateStakeReward(stakeRecord)
    │    = 1000 * (1.006)^10 ≈ 1061.68 USDT
    │
    ├─ 步骤3: 计算新增盈利 (line 300)
    │    newProfit = 1061.68 - 1000 = 61.68 USDT
    │
    ├─ 步骤4: 兑换 SYI → USDT (line 305-307) ⭐
    │    _swapSYIForReward(61.68 USDT)
    │    │
    │    ├─ 4.1 查询池子储备量
    │    ├─ 4.2 计算需要的 SYI 数量
    │    │     假设当前价格 1 SYI = 0.1 USDT
    │    │     需要 ≈ 616.8 SYI (加上滑点和手续费)
    │    ├─ 4.3 执行兑换
    │    │     Router.swapTokensForExactTokens(
    │    │         61.68 USDT,        // 精确输出
    │    │         maxSYIInput,       // 最大输入（滑点保护）
    │    │         [SYI, USDT],
    │    │         Staking合约,
    │    │         deadline
    │    │     )
    │    └─ 4.4 返回
    │          usdtReceived = 61.68 USDT
    │          syiTokensUsed = 616.8 SYI
    │
    ├─ 步骤5: 分配奖励 (line 310-316)
    │    interestEarned = 61.68 USDT
    │    │
    │    ├─ 5.1 Friend 奖励 (5%)
    │    │    friendReward = 61.68 * 5% = 3.08 USDT
    │    │    USDT.transfer(friend 或 rootAddress, 3.08)
    │    │
    │    └─ 5.2 Team 奖励 (最高35%)
    │         teamFee = 61.68 * 35% = 21.59 USDT (最大)
    │         _distributeTeamReward(...)
    │         └─ 按差额分配给 V1-V7 团队成员
    │
    ├─ 步骤6: 收取 Redemption Fee (line 319-335)
    │    userPayout = 61.68 - 3.08 - 21.59 = 37.01 USDT
    │    redemptionFeeUSDT = 37.01 * 1% = 0.37 USDT
    │    │
    │    └─ 兑换并转账给 feeRecipient
    │         _swapSYIForReward(0.37 USDT)
    │
    ├─ 步骤7: ⚠️ 重置复利起点 (line 341-343)
    │    oldStakeTime = 质押时间 (T0)
    │    stakeRecord.stakeTime = block.timestamp (T0 + 10天)
    │    stakeRecord.amount = 1000 (本金不变)
    │    stakeRecord.originalEndTime = T0 + 30天 (到期时间不变)
    │    stakeRecord.totalWithdrawn += 61.68
    │
    ├─ 步骤8: 转账给用户 (line 347)
    │    finalPayout = 37.01 - 0.37 = 36.64 USDT
    │    USDT.transfer(用户, 36.64)
    │
    ├─ 步骤9: 回收 SYI (line 350)
    │    totalSYIUsed = 616.8 + redemptionFeeSYI
    │    SYI.recycle(totalSYIUsed)
    │    └─ SYI 从 Pair 池子转回 Staking 合约
    │
    └─ 发出事件 InterestWithdrawn & CompoundInterestReset
```

### 资金流向图

```
质押记录状态变化:
┌──────────────────────────────────────────────────────────┐
│ 提取前:                                                   │
│   amount: 1000 USDT                                      │
│   stakeTime: T0                                          │
│   originalEndTime: T0 + 30天                             │
│   当前价值: 1061.68 USDT (复利10天)                       │
└──────────────────────────────────────────────────────────┘
                        ↓
                  withdrawInterest()
                        ↓
┌──────────────────────────────────────────────────────────┐
│ 提取后:                                                   │
│   amount: 1000 USDT (本金不变)                            │
│   stakeTime: T0 + 10天 (⚠️ 复利起点重置)                  │
│   originalEndTime: T0 + 30天 (到期时间不变)               │
│   totalWithdrawn: 61.68 USDT                             │
│   当前价值: 1000 USDT (从新起点开始复利)                   │
└──────────────────────────────────────────────────────────┘


资金分配 (61.68 USDT 利息):
                ┌─────────────────┐
                │  61.68 USDT     │
                │  (新增利息)      │
                └────────┬────────┘
                         │
         ┌───────────────┼───────────────┐
         │               │               │
         ↓               ↓               ↓
    Friend 5%       Team 35%        用户 60%
    (3.08 USDT)    (21.59 USDT)   (37.01 USDT)
         │               │               │
         │               │               ├─→ Redemption Fee 1%
         │               │               │    (0.37 USDT)
         │               │               │
         ↓               ↓               ↓
    直接转账      差额分配给      实际到账: 36.64 USDT
                 V1-V7 成员
```

### SYI 兑换详解

```
_swapSYIForReward(61.68 USDT) 的内部流程:

1. 查询 Staking 合约的 SYI 余额
   syiBalanceBefore = 100,000 SYI

2. 查询当前池子价格
   假设: 1 SYI = 0.1 USDT
   需要的 SYI ≈ 61.68 / 0.1 = 616.8 SYI

3. 计算最大输入 (含滑点)
   maxSYIInput = _calculateMaxSYIInput(61.68, 100000)
   = 616.8 * 1.5 = 925.2 SYI (50% 缓冲)

4. 执行精确输出兑换
   Router.swapTokensForExactTokens(
       61.68 USDT,          // 精确输出
       925.2 SYI,           // 最大输入
       [SYI, USDT],
       Staking合约
   )

5. 计算实际使用
   syiBalanceAfter = 99,350 SYI
   syiTokensUsed = 100000 - 99350 = 650 SYI (实际)
   usdtReceived = 61.68 USDT

6. 返回结果
   return (61.68 USDT, 650 SYI)
```

### 复利重置机制说明

这是 `withdrawInterest` 的关键设计:

```
时间线示例:
T0 (质押)      T0+10天 (提取)                    T0+30天 (到期)
│                │                                  │
├────────────────┼──────────────────────────────────┤
│  复利计算区1   │         复利计算区2              │
│  1000→1061.68  │      1000→? (重新复利)           │
│                │                                  │
│                ↓                                  │
│          提取 61.68 USDT                          │
│          本金重置为 1000                           │
│          从此刻开始重新复利                         │
```

**为什么要重置?**
- 防止双重计息: 如果不重置，到期时会对已提取的部分再次计算复利
- 公平性: 用户提前兑现了利息，应该基于剩余本金重新计算
- 灵活性: 允许用户在期限内多次提取，每次都从当前本金开始计息

---

## 解质押流程 (unstake)

### 函数入口
```solidity
function unstake(uint256 stakeIndex) external onlyEOA
    returns (uint256 totalReward)
```
**位置**: `StakingBase.sol:381`

### 详细流程

```
┌────────────────────────────────────────────────────────────────┐
│                        解质押流程                               │
└────────────────────────────────────────────────────────────────┘

用户: 质押 1000 USDT，30天期限已到期
    │
    ├─ 步骤1: _burn(stakeIndex) (line 1176-1198)
    │    │
    │    ├─ 1.1 检查是否到期 (line 1184)
    │    │    require(block.timestamp >= originalEndTime)
    │    │
    │    ├─ 1.2 检查是否已提取 (line 1187)
    │    │    require(!user_record.status)
    │    │
    │    ├─ 1.3 计算最终收益 (line 1190)
    │    │    reward = _calculateStakeReward(user_record)
    │    │    = 1000 * (1.006)^30 ≈ 1197.4 USDT
    │    │
    │    ├─ 1.4 标记为已提取 (line 1191)
    │    │    user_record.status = true
    │    │
    │    └─ 1.5 销毁 sSYI (line 1193)
    │         _update(用户, address(0), 1000)
    │         totalSupply -= 1000
    │         balances[用户] -= 1000
    │
    ├─ 步骤2: 兑换 SYI → USDT (line 385-387)
    │    _swapSYIForReward(1197.4 USDT)
    │    返回: (1197.4 USDT, 11974 SYI)  // 假设 1 SYI = 0.1 USDT
    │
    ├─ 步骤3: 计算利息 (line 389-391)
    │    interestEarned = 1197.4 - 1000 = 197.4 USDT
    │
    ├─ 步骤4: 分配奖励 (line 393-398)
    │    ├─ Friend 奖励: 197.4 * 5% = 9.87 USDT
    │    └─ Team 奖励: 197.4 * 35% = 69.09 USDT
    │
    ├─ 步骤5: 收取 Redemption Fee (line 405-423)
    │    userPayout = 1197.4 - 9.87 - 69.09 = 1118.44 USDT
    │    redemptionFee = 1118.44 * 1% = 11.18 USDT
    │
    ├─ 步骤6: 更新团队投资值 (line 400)
    │    _updateTeamInvestmentValues(用户, 1000, false)
    │    └─ 向上传播，减少推荐链的 teamTotalInvestValue
    │
    ├─ 步骤7: 记录提现历史 (line 426-437)
    │    _recordWithdrawal(...) 记录详细信息
    │
    ├─ 步骤8: 转账给用户 (line 439)
    │    finalPayout = 1118.44 - 11.18 = 1107.26 USDT
    │    USDT.transfer(用户, 1107.26)
    │
    └─ 步骤9: 回收 SYI (line 442)
         SYI.recycle(totalSYIUsed)
```

### 资金流向图

```
质押记录状态:
┌──────────────────────────────────────────────────────────┐
│ 解质押前:                                                 │
│   本金: 1000 USDT                                        │
│   期限: 30 天                                            │
│   当前价值: 1197.4 USDT (0.6%日复利30天)                  │
│   sSYI 余额: 1000                                        │
└──────────────────────────────────────────────────────────┘
                        ↓
                    unstake()
                        ↓
┌──────────────────────────────────────────────────────────┐
│ 解质押后:                                                 │
│   status: true (已解质押)                                 │
│   sSYI 余额: 0 (已销毁)                                   │
│   totalSupply: -1000                                     │
└──────────────────────────────────────────────────────────┘


资金分配 (1197.4 USDT 总收益):
                ┌─────────────────┐
                │  1197.4 USDT    │
                │  (总收益)        │
                └────────┬────────┘
                         │
         ┌───────────────┼────────────────┐
         │               │                │
      本金 1000       利息 197.4           │
         │               │                │
         │       ┌───────┴────────┐       │
         │       │                │       │
         │       ↓                ↓       │
         │   Friend 5%        Team 35%    │
         │   (9.87)           (69.09)     │
         │                                │
         └────────────┬───────────────────┘
                      │
                      ↓
              用户应得: 1118.44 USDT
                      │
                      ├─→ Redemption Fee 1%
                      │    (11.18 USDT → feeRecipient)
                      │
                      ↓
              实际到账: 1107.26 USDT
```

### 与 withdrawInterest 的区别

| 项目 | withdrawInterest | unstake |
|------|-----------------|---------|
| 提取对象 | 仅利息 | 本金 + 利息 |
| 本金状态 | 保留质押 | 解除质押 |
| sSYI 余额 | 不变 | 销毁 |
| 复利起点 | 重置为当前 | N/A |
| 到期时间 | 不变 | N/A |
| 团队KPI | 不变 | 减少 |
| 调用时机 | 期限内 | 期限结束后 |

---

## 奖励分配机制

### 1. Friend 奖励 (直推 5%)

**函数**: `_distributeFriendReward`
**位置**: `StakingBase.sol:1277`

```solidity
function _distributeFriendReward(address _user, uint256 _interset)
    private returns (uint256 fee)
{
    fee = (_interset * 5) / 100;  // 5% 固定比例

    address friend = getFriend(_user);
    if (friend != address(0)) {
        USDT.transfer(friend, fee);   // 转给 friend
    } else {
        USDT.transfer(rootAddress, fee);  // 没有 friend 则给 root
    }
}
```

**流程图**:
```
用户利息: 100 USDT
     │
     ├─→ 计算 Friend 奖励: 100 * 5% = 5 USDT
     │
     └─→ 检查 friend 地址
           │
           ├─ 已绑定 friend ──→ transfer(friend, 5 USDT)
           │
           └─ 未绑定 ────────→ transfer(rootAddress, 5 USDT)
```

**关键点**:
- Friend 是**独立的直推收益地址**，不影响推荐树
- 用户通过 `lockFriend(address)` 绑定，永久生效
- 如果不绑定，5% 默认给 `rootAddress`

### 2. Team 奖励 (差额最高 35%)

**函数**: `_distributeTeamReward`
**位置**: `StakingBase.sol:1292`

#### 团队等级系统

| 等级 | 团队KPI门槛 | 奖励比例 | 累计比例 |
|------|------------|---------|---------|
| V1 | 10,000 USDT | 5% | 5% |
| V2 | 50,000 USDT | 5% | 10% |
| V3 | 200,000 USDT | 5% | 15% |
| V4 | 500,000 USDT | 5% | 20% |
| V5 | 1,000,000 USDT | 5% | 25% |
| V6 | 2,500,000 USDT | 5% | 30% |
| V7 | 5,000,000 USDT | 5% | 35% |

**KPI 说明**:
- `teamTotalInvestValue[user]` = 下级所有人的质押本金总和
- 包括直推和间接推荐的所有层级

#### 差额分配机制

```
示例: 用户 A 产生 100 USDT 利息

推荐链:
A → B (V3, 15%) → C (V2, 10%) → D (V1, 5%) → E (V0, 0%)

分配计算:
1. B 获得: 15% - 10% = 5% → 5 USDT
2. C 获得: 10% - 5% = 5% → 5 USDT
3. D 获得: 5% - 0% = 5% → 5 USDT
4. E 获得: 0 USDT (无等级)

总分配: 15 USDT
剩余: 35% - 15% = 20% → 20 USDT 给 rootAddress
```

**流程图**:
```
┌────────────────────────────────────────────────────────┐
│              Team 奖励差额分配流程                       │
└────────────────────────────────────────────────────────┘

1. 获取推荐链 (最多 30 层)
   getReferrals(用户, 30) → [上级1, 上级2, ...]

2. 计算每个上级的等级
   for each 上级 in 推荐链:
       tier = _getUserTier(上级)
       └─→ 检查:
            ├─ isPreacher (质押 >= 200 SYI)
            ├─ teamKPI 门槛
            └─ nodeTier (节点等级加成)

3. 差额分配 (_distributeHybridRewards)
   cumulativeRate = 0

   for tier in [V7→V1]:  // 从高到低查找
       if (推荐链中有此等级 && 该成员是 Preacher):
           actualRate = tierRate - cumulativeRate
           reward = 利息 * actualRate / 100
           transfer(成员, reward)
           cumulativeRate = tierRate

4. 剩余分配给 rootAddress
   remaining = 35% - cumulativeRate
   transfer(rootAddress, 利息 * remaining / 100)
```

#### Preacher 资格

**定义**: `currentStakeValue(user) >= 200 SYI`

```solidity
function isPreacher(address user) public view returns (bool) {
    return currentStakeValue(user) >= PREACHER_THRESHOLD;  // 200 ether
}
```

**作用**:
- 只有 Preacher 才能获得团队奖励
- 非 Preacher 的等级不计入分配
- 发出事件 `PreacherCheckFailed`

#### 节点等级系统

**管理员**: `tierManager` 地址
**等级范围**: V1 或 V2
**设置函数**: `setNodeTier(address user, uint8 tier)`

**等级计算公式**:
```solidity
finalTier = MAX(naturalTier, nodeTier)
```

- **naturalTier**: 基于 teamKPI 自然达到的等级
- **nodeTier**: 管理员手动设置的等级（仅 V1/V2）
- **finalTier**: 实际生效的等级（取两者最大值）

**示例**:
```
用户 X:
  - teamKPI: 8,000 USDT → naturalTier = 0 (未达V1门槛)
  - nodeTier: V1 (管理员设置)
  - finalTier: MAX(0, 1) = V1 ✅

用户 Y:
  - teamKPI: 300,000 USDT → naturalTier = V3
  - nodeTier: V1 (管理员设置)
  - finalTier: MAX(3, 1) = V3 ✅ (自然等级更高)
```

### 3. Redemption Fee (赎回费 1%)

**费率**: `REDEMPTION_FEE_RATE = 100 bps = 1%`
**收费对象**: 用户应得部分 (扣除 friend 和 team 后)
**接收地址**: `feeRecipient`

**计算流程**:
```
总收益: 1000 USDT
  ├─ Friend 5%: 50 USDT
  ├─ Team 35%: 350 USDT
  └─ 用户应得: 600 USDT
       │
       ├─ Redemption Fee 1%: 6 USDT
       │    └─→ 转给 feeRecipient
       │
       └─ 实际到账: 594 USDT
```

**代码** (line 405-423):
```solidity
uint256 userPayout = usdtReceived - friendReward - teamFee;

uint256 expectedRedemptionFeeUSDT =
    (userPayout * REDEMPTION_FEE_RATE) / BASIS_POINTS_DENOMINATOR;

if (expectedRedemptionFeeUSDT > 0 && feeRecipient != address(0)) {
    // 兑换 SYI 为 USDT 用于收费
    (, uint256 redemptionFeeSYIUsed) =
        _swapSYIForReward(expectedRedemptionFeeUSDT);

    emit RedemptionFeeCollected(...);
}

USDT.transfer(msg.sender, userPayout);  // 转账时已包含 fee
```

**⚠️ 注意**:
- Redemption Fee 从 **SYI 池子** 额外兑换
- 不从用户应得的 USDT 中扣除
- 相当于额外的 SYI 消耗

---

## 复利计算机制

### 复利公式

**函数**: `_calculateStakeReward`
**位置**: `StakingBase.sol:1445`

**数学公式**:
```
最终价值 = 本金 × (1 + 日利率)^复利次数

例如:
  本金 = 1000 USDT
  日利率 = 0.6% (stakeIndex = 1)
  复利次数 = 30 天

  最终价值 = 1000 × (1.006)^30
           = 1000 × 1.1967424
           = 1196.74 USDT
```

### Solidity 实现

```solidity
function _calculateStakeReward(
    IStaking.Record storage stakeRecord
) private view returns (uint256 currentReward) {
    // 1. 获取本金
    UD60x18 principalAmount = ud(stakeRecord.amount);

    // 2. 计算有效时间范围
    uint40 effectiveEndTime = _min40(
        uint40(block.timestamp),
        stakeRecord.originalEndTime  // ⚠️ 不超过到期时间
    );

    uint40 stakingDuration = effectiveEndTime - stakeRecord.stakeTime;

    // 3. 转换为复利周期数
    // mainnet: 1 days, testnet: 1 (秒)
    uint256 compoundPeriods = stakingDuration / getCompoundTimeUnit();

    // 4. 复利计算 (使用 PRB Math 库)
    UD60x18 baseInterestRate = ud(rates[stakeRecord.stakeIndex]);
    // rates[1] = 1006000000000000000 = 1.006

    UD60x18 compoundedAmount = principalAmount.mul(
        baseInterestRate.powu(compoundPeriods)  // 幂运算
    );

    // 5. 返回最终价值
    currentReward = UD60x18.unwrap(compoundedAmount);
}
```

### 关键时间点

**三个时间戳**:
1. **startTime**: 原始质押时间 (不变)
2. **stakeTime**: 复利计算起点 (可重置)
3. **originalEndTime**: 到期时间 (不变)

```
startTime          stakeTime                originalEndTime
    │                 │                           │
    ├─────────────────┼───────────────────────────┤
    │   忽略区域      │     复利计算区域           │
    │                 │                           │
  质押时刻        上次重置时刻                  到期时刻
```

**场景 1: 正常质押**
```
T0 (质押)                                    T30 (到期)
├────────────────────────────────────────────┤
stakeTime=T0                    originalEndTime=T30

复利时间 = T30 - T0 = 30 天
复利次数 = 30
```

**场景 2: 提前提取利息后**
```
T0 (质押)      T10 (提取)                    T30 (到期)
├──────────────┼──────────────────────────────┤
startTime=T0   stakeTime=T10    originalEndTime=T30

提取时:
  复利时间 = T10 - T0 = 10 天
  复利次数 = 10

提取后 (stakeTime 重置):
  新的 stakeTime = T10
  剩余复利时间 = T30 - T10 = 20 天
```

**场景 3: 到期后未提取**
```
T0 (质押)                   T30 (到期)    T35 (现在)
├───────────────────────────┤              │
stakeTime=T0   originalEndTime=T30    block.timestamp

计算时:
  effectiveEndTime = min(T35, T30) = T30
  复利时间 = T30 - T0 = 30 天 (不会超过期限)
```

### 高精度数学库

**使用**: `@prb/math` 库的 `UD60x18` 类型

**精度**: 60.18 固定点数 (60位整数 + 18位小数)

```solidity
import {UD60x18, ud} from "@prb/math/src/UD60x18.sol";

// 示例
UD60x18 rate = ud(1006000000000000000);  // 1.006
UD60x18 principal = ud(1000 ether);      // 1000

UD60x18 result = principal.mul(rate.powu(30));
// result = 1000 * (1.006)^30 ≈ 1196.74
```

**为什么需要高精度?**
- Solidity 原生不支持浮点数
- 普通整数运算会丢失小数
- 复利计算需要精确到小数点后18位

---

## 关键常量与费率

### 1. 费率常量

```solidity
// 基础比例
uint256 constant BASIS_POINTS_DENOMINATOR = 10000;  // 1 bp = 0.01%
uint256 constant PERCENTAGE_BASE = 100;

// 奖励比例
uint256 constant REFERRAL_REWARD_RATE = 5;         // Friend 5%
uint256 constant MAX_TEAM_REWARD_RATE = 35;        // Team 最高35%
uint256 constant REDEMPTION_FEE_RATE = 100;        // Redemption 1% = 100bp

// 团队等级奖励
uint256 constant TEAM_REWARD_TIER_1 = 5;           // V1: 5%
uint256 constant TEAM_REWARD_TIER_2 = 10;          // V2: 10%
uint256 constant TEAM_REWARD_TIER_3 = 15;          // V3: 15%
uint256 constant TEAM_REWARD_TIER_4 = 20;          // V4: 20%
uint256 constant TEAM_REWARD_TIER_5 = 25;          // V5: 25%
uint256 constant TEAM_REWARD_TIER_6 = 30;          // V6: 30%
uint256 constant TEAM_REWARD_TIER_7 = 35;          // V7: 35%
```

### 2. 限额常量

```solidity
uint256 constant MAX_STAKE_LIMIT = 1000 ether;         // 单次最大质押
uint256 constant MAX_USER_TOTAL_STAKE = 10000 ether;   // 用户总质押上限
uint256 constant PREACHER_THRESHOLD = 200 ether;       // Preacher 门槛
uint8 constant MAX_REFERRAL_DEPTH = 30;                // 最大推荐层数
uint8 constant MAX_STAKE_INDEX = 3;                    // 质押档位数量
```

### 3. 滑点保护

```solidity
uint256 constant BASE_SLIPPAGE_TOLERANCE = 1500;       // 15% 基础滑点
uint256 constant MAX_SLIPPAGE_TOLERANCE = 2000;        // 20% 最大滑点
uint256 constant PRICE_IMPACT_THRESHOLD = 200;         // 2% 价格影响阈值

// SYI 买入税费 (用于滑点计算)
uint256 constant SYI_BUY_BURN_FEE_BPS = 50;           // 0.5% burn
uint256 constant SYI_BUY_LIQUIDITY_FEE_BPS = 250;     // 2.5% LP
uint256 constant SYI_TOTAL_BUY_FEE_BPS = 300;         // 3% 总税
```

### 4. 质押期限与利率 (主网)

```solidity
// 期限
function getStakePeriod1D() returns (uint256) { return 1 days; }
function getStakePeriod30D() returns (uint256) { return 30 days; }
function getStakePeriod90D() returns (uint256) { return 90 days; }
function getStakePeriod180D() returns (uint256) { return 180 days; }

// 日复利利率 (18位精度)
function getAPYRate1D() returns (uint256) {
    return 1003000000000000000;  // 1.003 = 0.3%/日
}
function getAPYRate30D() returns (uint256) {
    return 1006000000000000000;  // 1.006 = 0.6%/日
}
function getAPYRate90D() returns (uint256) {
    return 1009000000000000000;  // 1.009 = 0.9%/日
}
function getAPYRate180D() returns (uint256) {
    return 1015000000000000000;  // 1.015 = 1.5%/日
}

// 复利周期
function getCompoundTimeUnit() returns (uint256) {
    return 1 days;  // 主网: 每天复利
}
```

### 5. 团队等级门槛

```solidity
function getTeamThresholdTier1() returns (uint256) {
    return 10_000 ether;      // V1: 1万 USDT
}
function getTeamThresholdTier2() returns (uint256) {
    return 50_000 ether;      // V2: 5万 USDT
}
function getTeamThresholdTier3() returns (uint256) {
    return 200_000 ether;     // V3: 20万 USDT
}
function getTeamThresholdTier4() returns (uint256) {
    return 500_000 ether;     // V4: 50万 USDT
}
function getTeamThresholdTier5() returns (uint256) {
    return 1_000_000 ether;   // V5: 100万 USDT
}
function getTeamThresholdTier6() returns (uint256) {
    return 2_500_000 ether;   // V6: 250万 USDT
}
function getTeamThresholdTier7() returns (uint256) {
    return 5_000_000 ether;   // V7: 500万 USDT
}
```

### 6. 费用分配汇总表

| 费用类型 | 比例 | 计算基数 | 接收者 | 代码位置 |
|---------|------|---------|--------|---------|
| Friend 奖励 | 5% | 利息 | friend 或 root | line 1277 |
| Team V1 | 5% | 利息 | V1 成员 (差额) | line 1600 |
| Team V2 | 10% | 利息 | V2 成员 (差额) | line 1601 |
| Team V3 | 15% | 利息 | V3 成员 (差额) | line 1602 |
| Team V4 | 20% | 利息 | V4 成员 (差额) | line 1603 |
| Team V5 | 25% | 利息 | V5 成员 (差额) | line 1604 |
| Team V6 | 30% | 利息 | V6 成员 (差额) | line 1605 |
| Team V7 | 35% | 利息 | V7 成员 (差额) | line 1606 |
| Redemption Fee | 1% | 用户应得 | feeRecipient | line 405 |

**总费用计算示例**:
```
利息: 100 USDT
├─ Friend: 5 USDT (5%)
├─ Team: 35 USDT (35%, 按差额分配)
├─ 用户应得: 60 USDT (60%)
│   └─ Redemption: 0.6 USDT (1%)
└─ 实际到账: 59.4 USDT
```

---

## 总结

### 资金流向总览

```
┌────────────────────────────────────────────────────────┐
│                   完整资金流向                          │
└────────────────────────────────────────────────────────┘

阶段1: 质押
  用户 USDT → Staking 合约 → (50% Swap + 50% 直接)
  → 添加流动性 → LP 销毁

阶段2: 收益累积
  时间流逝 → 复利计算 → 账面价值增长

阶段3: 提取 (withdrawInterest 或 unstake)
  质押记录 → 计算收益 → 兑换 SYI → 获得 USDT
  → 分配奖励:
      ├─ Friend 5%
      ├─ Team 最高35% (差额)
      ├─ Redemption 1%
      └─ 用户剩余

阶段4: SYI 循环
  Staking.recycle() ← Pair 池子 ← 交易手续费累积
```

### 关键设计亮点

1. **LP 永久锁定**: 质押时 LP 代币销毁，保证流动性只增不减
2. **差额奖励**: 团队奖励避免重复分配，公平合理
3. **复利重置**: 提前提取利息后重新计算，防止双重计息
4. **节点等级**: 管理员可手动设置 V1/V2，作为最低保障
5. **Preacher 门槛**: 必须质押 ≥200 SYI 才能获得团队奖励
6. **滑点保护**: 动态计算滑点容忍度，适应不同价格影响

### 潜在风险点

⚠️ **注意事项**:
1. **SYI 价格波动**: 收益以 SYI 计价，兑换 USDT 时受价格影响
2. **流动性不足**: 大额提取可能导致滑点过大
3. **复利计算精度**: 依赖 PRB Math 库，需确保正确性
4. **推荐链深度**: 最多 30 层，超出部分不计入
5. **Redemption Fee**: 从池子额外兑换，增加 SYI 消耗

---

## 参考代码位置

- **质押**: `StakingBase.sol:270` (`stake`)
- **提前提息**: `StakingBase.sol:283` (`withdrawInterest`)
- **解质押**: `StakingBase.sol:381` (`unstake`)
- **复利计算**: `StakingBase.sol:1445` (`_calculateStakeReward`)
- **添加流动性**: `StakingBase.sol:1490` (`_swapAndAddLiquidity`)
- **兑换奖励**: `StakingBase.sol:1200` (`_swapSYIForReward`)
- **Friend 奖励**: `StakingBase.sol:1277` (`_distributeFriendReward`)
- **Team 奖励**: `StakingBase.sol:1292` (`_distributeTeamReward`)
- **等级计算**: `StakingBase.sol:1541` (`_getUserTier`)
- **SYI 回收**: `SYIBase.sol:249` (`recycle`)
