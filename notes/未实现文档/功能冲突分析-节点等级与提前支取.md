# 功能冲突分析：节点等级管理 vs 提前支取盈利

## 文档信息
- **创建时间**: 2025-10-14
- **分析范围**: 节点等级管理系统 + 提前支取盈利功能
- **合约版本**: StakingBase.sol
- **风险等级**: 🟡 中等（需要协调设计，但无致命冲突）

---

## 一、功能概述对比

### 1.1 节点等级管理系统

**核心变更**:
```solidity
// 新增数据结构
struct NodeTierRecord {
    uint8 tier;        // 1 byte
    uint40 setTime;    // 5 bytes
    address setBy;     // 20 bytes
    bool active;       // 1 byte
}

address public tierManager;
mapping(address => NodeTierRecord) public nodeTiers;

// 修改核心函数
function _getUserTier(address user) private view returns (uint8) {
    // 原逻辑：仅基于 teamKPI 计算
    // 新逻辑：MAX(自然等级, 节点等级)
}
```

**影响范围**:
- ✅ _getUserTier (修改计算逻辑)
- ✅ _distributeHybridRewards (间接影响，通过 _getUserTier)
- ✅ getTeamPerformanceDetails (查询功能)

---

### 1.2 提前支取盈利功能

**核心变更**:
```solidity
// 修改现有数据结构
struct Record {
    uint40 stakeTime;
    uint160 amount;
    uint160 withdrawnProfit;  // ⭐ 新增字段
    bool status;
    uint8 stakeIndex;
}

// 新增状态变量
mapping(address => mapping(uint256 => uint40)) public lastInterestWithdrawTime;
uint256 public constant INTEREST_WITHDRAW_COOLDOWN = 30 days;

// 新增核心函数
function withdrawInterest(uint256 stakeIndex) external returns (uint256);

// 修改现有函数
function unstake(uint256 stakeIndex) external {
    // 需要减去 withdrawnProfit
}
```

**影响范围**:
- ✅ Record 结构体（存储布局变化）
- ✅ unstake 函数（需适配已提取盈利）
- ✅ 费用分配逻辑（新增一个提取入口）

---

## 二、冲突点详细分析

### 2.1 数据结构冲突（🟢 低风险）

#### 冲突描述

**节点等级功能**：
- 新增 `NodeTierRecord` 结构体
- 新增 `mapping(address => NodeTierRecord) nodeTiers`
- 新增 `address tierManager`
- **不修改** `Record` 结构体

**提前支取功能**：
- **修改** `Record` 结构体（添加 `withdrawnProfit` 字段）
- 新增 `mapping(address => mapping(uint256 => uint40)) lastInterestWithdrawTime`
- **不修改**其他结构体

#### 存储布局影响

```solidity
// 原 Record 结构 (1 个 slot)
struct Record {
    uint40 stakeTime;      // 40 bits
    uint160 amount;        // 160 bits
    bool status;           // 8 bits
    uint8 stakeIndex;      // 8 bits
    // 总计: 216 bits < 256 bits → 1 slot
}

// 提前支取功能修改后 (2 个 slot)
struct Record {
    uint40 stakeTime;          // Slot 0: 40 bits
    uint160 amount;            // Slot 0: 160 bits
    uint160 withdrawnProfit;   // Slot 1: 160 bits  ⚠️ 新增
    bool status;               // Slot 1: 8 bits
    uint8 stakeIndex;          // Slot 1: 8 bits
    // 总计: 376 bits → 2 slots
}

// 节点等级功能新增 (独立存储)
mapping(address => NodeTierRecord) nodeTiers;  // 每用户 1 slot
```

#### 结论
✅ **无冲突**：两个功能的数据结构修改是独立的
- Record 修改仅影响质押记录
- NodeTierRecord 是独立的 mapping
- 两者不会互相覆盖或冲突

⚠️ **注意事项**：
- Record 结构体从 1 slot 变成 2 slots，每个质押记录增加 ~20,000 gas
- 必须在合约部署前完成修改，否则需要代理升级

---

### 2.2 函数调用链冲突（🟡 中风险）

#### 调用链图示

```
节点等级功能的调用链：
unstake()
  └─ _distributeTeamReward()
       └─ _distributeHybridRewards()
            └─ _getUserTier()  ⚠️ 修改：增加节点等级逻辑

提前支取功能的调用链：
withdrawInterest()  ⚠️ 新增函数
  ├─ _calculateStakeReward()
  ├─ _swapSYIForReward()
  ├─ _distributeFriendReward()
  └─ _distributeTeamReward()
       └─ _distributeHybridRewards()
            └─ _getUserTier()  ⚠️ 会受节点等级功能影响

unstake()  ⚠️ 修改
  ├─ _burn()
  ├─ _calculateStakeReward()  ⚠️ 需要减去 withdrawnProfit
  ├─ _swapSYIForReward()
  ├─ _distributeFriendReward()
  └─ _distributeTeamReward()
```

#### 冲突点

**问题1：withdrawInterest 会触发节点等级的团队奖励计算**

场景：
```
用户A: 节点等级 V1, 自然等级 0, 质押 200 SYI (Preacher ✓)
用户B: A 的直接下级, 质押 1000 USDT

Day 15: B 调用 withdrawInterest(0)
  → 计算盈利: 93.8 USDT
  → 调用 _distributeTeamReward(B的推荐链, 93.8)
  → _getUserTier(A) = 1 (节点等级生效)
  → A 获得: 93.8 × 5% = 4.69 USDT  ✅

Day 30: B 调用 unstake(0)
  → 计算剩余盈利: 198.8 - 93.8 = 105.0 USDT
  → 调用 _distributeTeamReward(B的推荐链, 105.0)
  → _getUserTier(A) = 1 (节点等级仍生效)
  → A 获得: 105.0 × 5% = 5.25 USDT  ✅

A 总共获得: 4.69 + 5.25 = 9.94 USDT
如果不提前支取，A 获得: 198.8 × 5% = 9.94 USDT  ✅ 一致
```

**结论**：✅ **逻辑正确**，分多次分配的总额 = 一次性分配的总额

---

**问题2：unstake 必须正确减去 withdrawnProfit**

提前支取功能文档在第 5.1 节已经说明：

```solidity
// 提前支取设计中要求的修改
function unstake(uint256 stakeIndex) external {
    (uint256 calculatedReward, uint256 principalAmount) = _burn(stakeIndex);

    // ⚠️ 新增：减去已提取的盈利
    Record storage stakeRecord = userStakeRecord[msg.sender][stakeIndex];
    uint256 remainingReward = calculatedReward - stakeRecord.withdrawnProfit;

    // 后续使用 remainingReward 而不是 calculatedReward
    (uint256 usdtReceived, uint256 syiTokensUsed) = _swapSYIForReward(remainingReward);
    // ...
}
```

**结论**：✅ **必须修改 unstake**，两个功能都要求这个修改

---

### 2.3 团队奖励计算逻辑冲突（🟢 低风险）

#### 场景分析

```
推荐链: 用户C → 用户B(节点等级V2) → 用户A(节点等级V1) → root

用户C 质押 1000 USDT (30天档)

情况1: C 在 Day 30 直接 unstake
- 盈利: 198.8 USDT
- A 获得: 198.8 × 5% = 9.94 USDT (V1)
- B 获得: 198.8 × 5% = 9.94 USDT (V2-V1 差额)
- root 获得: 198.8 × 25% = 49.7 USDT

情况2: C 分 3 次提取 (Day 10, 20, 30)
- Day 10: 盈利 62.3 USDT
  - A 获得: 62.3 × 5% = 3.12 USDT
  - B 获得: 62.3 × 5% = 3.12 USDT

- Day 20: 新增盈利 65.8 USDT
  - A 获得: 65.8 × 5% = 3.29 USDT
  - B 获得: 65.8 × 5% = 3.29 USDT

- Day 30: 剩余盈利 70.7 USDT
  - A 获得: 70.7 × 5% = 3.54 USDT
  - B 获得: 70.7 × 5% = 3.54 USDT

总计:
- A: 3.12 + 3.29 + 3.54 = 9.95 USDT ≈ 9.94 USDT  ✅
- B: 3.12 + 3.29 + 3.54 = 9.95 USDT ≈ 9.94 USDT  ✅
```

#### 结论
✅ **无冲突**：
- 节点等级的差额奖励机制在多次提取场景下仍然正确
- 总奖励 = 各次提取奖励之和
- 不存在重复分配或遗漏

---

### 2.4 Preacher 状态检查冲突（🟢 低风险）

#### 节点等级对 Preacher 的依赖

```solidity
// 节点等级功能的 _getUserTier 实现
function _getUserTier(address user) private view returns (uint8) {
    if (user == rootAddress) return 0;

    // ⚠️ 节点等级仅在 Preacher 时生效
    if (!isPreacher(user)) {
        return 0;  // 节点等级无效
    }

    uint8 naturalTier = _calculateNaturalTier(user);
    uint8 nodeTier = nodeTiers[user].active ? nodeTiers[user].tier : 0;

    return _max8(naturalTier, nodeTier);
}
```

#### 提前支取对 Preacher 状态的影响

```solidity
function isPreacher(address user) public view returns (bool) {
    return currentStakeValue(user) >= PREACHER_THRESHOLD; // 200 ether
}

// withdrawInterest 不改变本金，只提取盈利
function withdrawInterest(uint256 stakeIndex) external {
    // ...
    // ⚠️ 仅提取盈利，stakeRecord.amount 不变
    stakeRecord.withdrawnProfit += actualWithdraw;
    // balances[user] 不变
    // ...
}

// currentStakeValue 计算当前价值（包含盈利）
function currentStakeValue(address user) public view returns (uint256) {
    // 遍历所有质押记录，累加 _calculateStakeReward(stakeRecord)
    // withdrawnProfit 不影响此计算
}
```

#### 潜在问题

**场景**：
```
用户质押 200 SYI (刚好达到 Preacher 门槛)
- Day 0: currentStakeValue = 200 SYI → isPreacher = true
- Day 15: 提取盈利后
  - balances[user] = 200 SYI (本金未变)
  - currentStakeValue = 200 × 1.006^15 = 218.8 SYI
  - isPreacher = true ✅ (仍然满足)
```

**如果未来添加"提前取回部分本金"功能**：
```
用户质押 200 SYI
- 提前取回 50 SYI 本金
- balances[user] = 150 SYI
- currentStakeValue = 150 SYI (< 200)
- isPreacher = false ❌
- 节点等级失效 ❌
```

#### 结论
✅ **当前设计无冲突**：
- withdrawInterest 只提取盈利，不影响本金
- currentStakeValue 会随时间增长，不会因提取盈利而下降
- Preacher 状态稳定，节点等级不会意外失效

⚠️ **未来风险**：
- 如果扩展为"提前取回部分本金"，需要额外设计
- 建议：限制提取本金时必须保留 ≥ 200 SYI

---

### 2.5 复利计算冲突（🟢 无冲突）

#### 节点等级功能对复利计算的影响

节点等级功能**不修改** `_calculateStakeReward` 函数：

```solidity
function _calculateStakeReward(
    IStaking.Record storage stakeRecord
) private view returns (uint256 currentReward) {
    // 节点等级功能不修改此函数
    // 仍然使用原始的复利公式
    UD60x18 principalAmount = ud(stakeRecord.amount);
    uint40 stakingDuration = uint40(block.timestamp) - stakeRecord.stakeTime;
    // ...
}
```

#### 提前支取功能对复利计算的影响

提前支取功能**不修改** `_calculateStakeReward`，但修改其使用方式：

```solidity
// withdrawInterest 中使用
function withdrawInterest(uint256 stakeIndex) external {
    uint256 currentValue = _calculateStakeReward(stakeRecord);  // 计算总价值
    uint256 totalProfit = currentValue - stakeRecord.amount;    // 总盈利
    uint256 withdrawableProfit = totalProfit - stakeRecord.withdrawnProfit; // 可提取

    // ⚠️ stakeTime 不变，继续复利
}

// unstake 中使用
function unstake(uint256 stakeIndex) external {
    uint256 calculatedReward = _calculateStakeReward(stakeRecord);  // 计算总价值
    uint256 remainingReward = calculatedReward - stakeRecord.withdrawnProfit; // 减去已提取

    // 后续使用 remainingReward
}
```

#### 结论
✅ **无冲突**：
- 两个功能都不修改复利计算核心
- 提前支取功能通过 `withdrawnProfit` 追踪已提取金额
- 节点等级功能仅影响团队奖励分配，不影响收益计算

---

## 三、综合风险评估

### 3.1 风险矩阵

| 风险类别 | 概率 | 影响 | 风险等级 | 缓解措施 |
|---------|------|------|---------|---------|
| **存储布局变化** | 必然 | 中 | 🟡 中 | 部署前完成修改，或使用代理模式 |
| **团队奖励重复分配** | 无 | - | 🟢 低 | 数学验证通过，总额一致 |
| **节点等级失效** | 低 | 低 | 🟢 低 | withdrawInterest 不改变本金 |
| **复利计算错误** | 无 | - | 🟢 低 | 两功能都不修改核心公式 |
| **unstake 遗漏 withdrawnProfit** | 中 | 高 | 🟡 中 | 代码审查 + 测试覆盖 |
| **Gas 成本增加** | 必然 | 低 | 🟢 低 | Record 增加 1 slot，成本可接受 |
| **测试复杂度** | 必然 | 中 | 🟡 中 | 增加组合场景测试用例 |

### 3.2 关键风险详解

#### 风险1：unstake 必须减去 withdrawnProfit（🔴 高优先级）

**问题描述**：
如果 unstake 忘记减去 `stakeRecord.withdrawnProfit`，用户可以重复获得已提取的盈利。

**攻击场景**：
```
用户质押 1000 USDT (30天档)
Day 15: withdrawInterest(0) → 提取 93.8 USDT
Day 30: unstake(0) → 如果不减去 withdrawnProfit，会再次获得 198.8 USDT
总收益: 93.8 + 198.8 = 292.6 USDT (应该是 198.8 USDT)
```

**必须的代码修改**：
```solidity
function unstake(uint256 stakeIndex) external onlyEOA returns (uint256 totalReward) {
    (uint256 calculatedReward, uint256 principalAmount) = _burn(stakeIndex);

    // ⚠️ 必须添加：减去已提取盈利
    Record storage stakeRecord = userStakeRecord[msg.sender][stakeIndex];
    uint256 withdrawnProfit = stakeRecord.withdrawnProfit;

    // ⚠️ 安全检查
    require(calculatedReward >= withdrawnProfit, "Invalid withdrawn profit");

    uint256 remainingReward = calculatedReward - withdrawnProfit;

    // ⚠️ 后续所有逻辑使用 remainingReward 而不是 calculatedReward
    (uint256 usdtReceived, uint256 syiTokensUsed) = _swapSYIForReward(remainingReward);

    // 利息计算也需要调整
    uint256 interestEarned = usdtReceived > principalAmount
        ? usdtReceived - principalAmount
        : 0;

    // 费用分配基于 interestEarned (剩余利息)
    // ...
}
```

**缓解措施**：
1. ✅ 代码审查时重点检查
2. ✅ 测试用例必须覆盖"提取后再 unstake"场景
3. ✅ 添加 `require` 检查，防止 withdrawnProfit > calculatedReward

---

#### 风险2：存储布局变化需要谨慎处理（🟡 中优先级）

**问题描述**：
修改 Record 结构体会改变存储布局，已有数据可能无法读取。

**影响分析**：
```solidity
// 旧合约（已部署）
struct Record {
    uint40 stakeTime;    // Slot 0: bits 0-39
    uint160 amount;      // Slot 0: bits 40-199
    bool status;         // Slot 0: bits 200-207
    uint8 stakeIndex;    // Slot 0: bits 208-215
}

// 新合约（添加 withdrawnProfit）
struct Record {
    uint40 stakeTime;          // Slot 0: bits 0-39
    uint160 amount;            // Slot 0: bits 40-199
    uint160 withdrawnProfit;   // Slot 1: bits 0-159  ⚠️ 新增
    bool status;               // Slot 1: bits 160-167
    uint8 stakeIndex;          // Slot 1: bits 168-175
}

// 问题：旧数据的 status 和 stakeIndex 位置错乱！
// 旧合约中 status 在 Slot 0 的 bits 200-207
// 新合约中 status 在 Slot 1 的 bits 160-167
// 读取时会得到错误的值
```

**解决方案**：

**方案1：重新部署合约（推荐）**
- ✅ 优点：干净简单，无历史包袱
- ✅ 适用场景：合约未部署或用户数据可迁移
- ❌ 缺点：需要用户重新质押

**方案2：使用透明代理升级**
```solidity
// 部署代理合约
TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(
    stakingV1Address,
    proxyAdmin,
    ""
);

// 升级到 V2
proxyAdmin.upgrade(proxy, stakingV2Address);

// ⚠️ 注意：V2 的存储布局必须兼容 V1
// 只能在末尾添加新字段，不能插入中间
```

**方案3：添加独立 mapping（妥协方案）**
```solidity
// 不修改 Record，使用独立 mapping
struct Record {
    uint40 stakeTime;
    uint160 amount;
    bool status;
    uint8 stakeIndex;
    // 不添加新字段
}

// 独立存储已提取盈利
mapping(address => mapping(uint256 => uint256)) public userStakeWithdrawnProfit;

// 使用时
uint256 withdrawnProfit = userStakeWithdrawnProfit[user][stakeIndex];
```

**推荐策略**：
- 如果合约**未部署** → 直接修改 Record 结构体 ✅
- 如果合约**已部署但无用户** → 重新部署 ✅
- 如果合约**已部署且有用户** → 使用代理升级或独立 mapping ⚠️

---

#### 风险3：Gas 成本增加（🟢 低优先级）

**影响量化**：

```
提前支取功能的 Gas 消耗：
- 基础操作: ~10,000 gas
- _calculateStakeReward: ~5,000 gas
- _swapSYIForReward: ~100,000 gas
- _distributeFriendReward: ~30,000 gas
- _distributeTeamReward: ~50,000-200,000 gas (取决于推荐链深度)
- 存储更新 (withdrawnProfit): ~5,000 gas
总计: ~200,000-350,000 gas

节点等级功能的 Gas 消耗增加：
- _getUserTier 额外 SLOAD (nodeTiers): ~2,100 gas
- 如果使用节点等级，emit 事件: ~1,000 gas
unstake 增加: ~3,000 gas (< 1%)

Record 结构体增加 1 slot：
- 每次质押: +20,000 gas (SSTORE cold)
- 每次读取: +2,100 gas (SLOAD cold)
```

**结论**：
✅ Gas 增加在可接受范围内（< 10%）

---

## 四、设计协调建议

### 4.1 统一的 unstake 修改

两个功能都要求修改 unstake，需要协调为统一的实现：

```solidity
function unstake(
    uint256 stakeIndex
) external onlyEOA returns (uint256 totalReward) {
    // ========================================
    // 步骤1: 销毁质押记录（原有逻辑）
    // ========================================
    (uint256 calculatedReward, uint256 principalAmount) = _burn(stakeIndex);

    // ========================================
    // 步骤2: ⚠️ 新增 - 减去已提取盈利（提前支取功能）
    // ========================================
    Record storage stakeRecord = userStakeRecord[msg.sender][stakeIndex];
    uint256 withdrawnProfit = stakeRecord.withdrawnProfit;

    require(calculatedReward >= withdrawnProfit, "Invalid withdrawn profit");

    uint256 remainingReward = calculatedReward - withdrawnProfit;

    // ========================================
    // 步骤3: 兑换为 USDT（原有逻辑，使用 remainingReward）
    // ========================================
    (uint256 usdtReceived, uint256 syiTokensUsed) = _swapSYIForReward(
        remainingReward  // ⚠️ 改为 remainingReward
    );

    // ========================================
    // 步骤4: 计算利息（基于剩余奖励）
    // ========================================
    uint256 interestEarned = usdtReceived > principalAmount
        ? usdtReceived - principalAmount
        : 0;

    // ========================================
    // 步骤5: 费用分配（原有逻辑，节点等级功能会影响 _distributeTeamReward）
    // ========================================
    address[] memory referralChain = getReferrals(msg.sender, maxD);
    uint256 friendReward = _distributeFriendReward(msg.sender, interestEarned);

    // ⚠️ _distributeTeamReward 内部调用 _getUserTier
    // 节点等级功能修改了 _getUserTier，会在这里生效
    uint256 teamFee = _distributeTeamReward(referralChain, interestEarned);

    // ... 后续逻辑不变 ...
}
```

### 4.2 事件记录协调

建议统一事件命名和参数：

```solidity
// 提前支取功能的事件
event InterestWithdrawn(
    address indexed user,
    uint256 indexed stakeIndex,
    uint256 profitAmount,
    uint256 usdtReceived,
    uint256 userPayout,
    uint256 friendReward,
    uint256 teamReward,
    uint256 redemptionFee,
    uint256 timestamp
);

// 节点等级功能的事件
event NodeTierUsed(
    address indexed user,
    uint8 naturalTier,
    uint8 nodeTier,
    uint8 finalTier,
    string reason
);

// 建议：在 withdrawInterest 中也触发 NodeTierUsed
function withdrawInterest(uint256 stakeIndex) external {
    // ...

    // 如果团队奖励分配时使用了节点等级，记录事件
    // （可在 _distributeHybridRewards 中自动触发）

    // ...
}
```

### 4.3 查询函数协调

建议添加统一的用户信息查询函数：

```solidity
/**
 * @notice 查询用户的完整质押和等级信息
 */
function getUserCompleteInfo(
    address user,
    uint256 stakeIndex
) external view returns (
    // 质押信息
    uint256 principal,
    uint256 currentValue,
    uint256 totalProfit,
    uint256 withdrawnProfit,
    uint256 availableProfit,
    bool canWithdraw,
    uint256 timeRemaining,
    // 等级信息 (节点等级功能)
    bool isPreacherStatus,
    uint8 naturalTier,
    uint8 nodeTier,
    uint8 finalTier,
    bool usingNodeTier,
    // 提前支取信息
    bool canWithdrawInterest,
    uint256 interestCooldownRemaining
) {
    Record storage stakeRecord = userStakeRecord[user][stakeIndex];

    principal = stakeRecord.amount;
    currentValue = _calculateStakeReward(stakeRecord);
    totalProfit = currentValue - principal;
    withdrawnProfit = stakeRecord.withdrawnProfit;
    availableProfit = totalProfit - withdrawnProfit;

    // ... 其余字段 ...
}
```

---

## 五、测试用例设计

### 5.1 组合场景测试（必须）

```javascript
describe("节点等级 + 提前支取组合测试", function() {

    it("场景1: 节点等级用户提前支取，应获得相应等级的团队奖励", async function() {
        // 1. 设置推荐关系: C -> B -> A -> root
        await staking.connect(A).lockReferral(root.address);
        await staking.connect(B).lockReferral(A.address);
        await staking.connect(C).lockReferral(B.address);

        // 2. A 质押 200 SYI (Preacher)，无 teamKPI
        await staking.connect(A).stake(ethers.parseEther("200"), 0);

        // 3. 设置 A 为节点等级 V1
        await staking.setTierManager(tierManager.address);
        await staking.connect(tierManager).setNodeTier(A.address, 1);

        // 4. C 质押 1000 USDT
        await staking.connect(C).stake(ethers.parseEther("1000"), 1);

        // 5. Day 15: C 提前支取利息
        await time.increase(15 * 24 * 60 * 60);
        const balanceBeforeA = await usdt.balanceOf(A.address);
        await staking.connect(C).withdrawInterest(0);
        const balanceAfterA = await usdt.balanceOf(A.address);

        // 6. 验证 A 获得了 V1 的团队奖励 (5%)
        const rewardA = balanceAfterA - balanceBeforeA;
        const expectedReward = ethers.parseEther("93.8") * 5n / 100n; // 约 4.69 USDT

        expect(rewardA).to.be.closeTo(expectedReward, ethers.parseEther("0.1"));
    });

    it("场景2: 提前支取后 unstake，奖励总额应一致", async function() {
        // 1. 设置关系（同上）
        // ...

        // 2. C 质押 1000 USDT
        await staking.connect(C).stake(ethers.parseEther("1000"), 1);

        // 3. Day 15 提取利息
        await time.increase(15 * 24 * 60 * 60);
        const balanceBeforeA1 = await usdt.balanceOf(A.address);
        await staking.connect(C).withdrawInterest(0);
        const reward1 = (await usdt.balanceOf(A.address)) - balanceBeforeA1;

        // 4. Day 30 解除质押
        await time.increase(15 * 24 * 60 * 60);
        const balanceBeforeA2 = await usdt.balanceOf(A.address);
        await staking.connect(C).unstake(0);
        const reward2 = (await usdt.balanceOf(A.address)) - balanceBeforeA2;

        // 5. 验证总奖励 = 一次性 unstake 的奖励
        const totalReward = reward1 + reward2;
        const expectedTotal = ethers.parseEther("198.8") * 5n / 100n; // 约 9.94 USDT

        expect(totalReward).to.be.closeTo(expectedTotal, ethers.parseEther("0.1"));
    });

    it("场景3: 提前支取后失去 Preacher 资格，节点等级失效", async function() {
        // 1. A 质押 200 SYI (刚好 Preacher)
        await staking.connect(A).stake(ethers.parseEther("200"), 0);
        await staking.connect(tierManager).setNodeTier(A.address, 1);

        // 2. 验证节点等级生效
        let breakdown = await staking.getUserTierBreakdown(A.address);
        expect(breakdown.isPreacherStatus).to.be.true;
        expect(breakdown.finalTier).to.equal(1);

        // 3. A 提前支取利息（本金不变，仍是 Preacher）
        await time.increase(15 * 24 * 60 * 60);
        await staking.connect(A).withdrawInterest(0);

        // 4. 验证仍是 Preacher，节点等级仍生效
        breakdown = await staking.getUserTierBreakdown(A.address);
        expect(breakdown.isPreacherStatus).to.be.true;
        expect(breakdown.finalTier).to.equal(1);

        // ⚠️ 注意：如果未来添加"提前取回部分本金"功能，需要额外测试
    });

    it("场景4: unstake 正确减去 withdrawnProfit", async function() {
        // 1. C 质押 1000 USDT
        await staking.connect(C).stake(ethers.parseEther("1000"), 1);

        // 2. 记录 C 的初始余额
        const initialBalance = await usdt.balanceOf(C.address);

        // 3. Day 15 提取利息
        await time.increase(15 * 24 * 60 * 60);
        await staking.connect(C).withdrawInterest(0);
        const balanceAfterWithdraw = await usdt.balanceOf(C.address);
        const withdrawnAmount = balanceAfterWithdraw - initialBalance;

        // 4. Day 30 unstake
        await time.increase(15 * 24 * 60 * 60);
        await staking.connect(C).unstake(0);
        const finalBalance = await usdt.balanceOf(C.address);

        // 5. 验证总收益 = 完整的 30 天收益
        const totalReceived = finalBalance - initialBalance;
        const expectedTotal = ethers.parseEther("198.8"); // 30天收益

        expect(totalReceived).to.be.closeTo(expectedTotal, ethers.parseEther("1"));

        // 6. 验证 unstake 返回的金额 = 总收益 - 已提取
        const unstakeAmount = finalBalance - balanceAfterWithdraw;
        expect(unstakeAmount).to.be.closeTo(
            expectedTotal - withdrawnAmount,
            ethers.parseEther("0.5")
        );
    });

    it("场景5: 节点等级变化不影响已提取的盈利记录", async function() {
        // 1. A 获得节点等级 V1
        await staking.connect(A).stake(ethers.parseEther("200"), 0);
        await staking.connect(tierManager).setNodeTier(A.address, 1);

        // 2. C 质押并提取利息
        await staking.connect(C).stake(ethers.parseEther("1000"), 1);
        await time.increase(15 * 24 * 60 * 60);
        await staking.connect(C).withdrawInterest(0);

        // 3. 移除 A 的节点等级
        await staking.connect(tierManager).removeNodeTier(A.address);

        // 4. C unstake，验证总收益仍正确
        await time.increase(15 * 24 * 60 * 60);
        const balanceBefore = await usdt.balanceOf(C.address);
        await staking.connect(C).unstake(0);
        const balanceAfter = await usdt.balanceOf(C.address);

        // 虽然 A 的节点等级被移除，C 的总收益不受影响
        const totalReceived = balanceAfter - balanceBefore;
        expect(totalReceived).to.be.gt(0);
    });
});
```

### 5.2 边界条件测试

```javascript
describe("边界条件测试", function() {
    it("提取全部盈利后 unstake，应只返回本金", async function() {
        // 1. 质押 1000 USDT (1天档)
        await staking.stake(ethers.parseEther("1000"), 0);

        // 2. 1天后，提取全部盈利
        await time.increase(1 * 24 * 60 * 60);
        const profitAmount = await staking.canWithdrawInterest(user, 0).withdrawableProfit;
        await staking.withdrawInterest(0);

        // 3. 立即 unstake
        const balanceBefore = await usdt.balanceOf(user);
        await staking.unstake(0);
        const received = (await usdt.balanceOf(user)) - balanceBefore;

        // 4. 应该只收到本金（扣除费用后）
        expect(received).to.be.closeTo(
            ethers.parseEther("1000"),
            ethers.parseEther("50") // 允许费用误差
        );
    });

    it("节点等级用户提前支取 0 盈利应 revert", async function() {
        await staking.connect(tierManager).setNodeTier(user, 1);
        await staking.stake(ethers.parseEther("1000"), 0);

        // 立即尝试提取（无盈利）
        await expect(
            staking.withdrawInterest(0)
        ).to.be.revertedWith("No new profit to withdraw");
    });
});
```

---

## 六、实施建议

### 6.1 开发顺序（推荐）

```
阶段1: 数据结构修改 (1天)
├─ 修改 Record 结构体 (添加 withdrawnProfit)
├─ 添加 NodeTierRecord 和相关 mapping
├─ 编译验证
└─ 存储布局测试

阶段2: 节点等级功能 (2-3天)
├─ 实现 setTierManager / setNodeTier 等管理函数
├─ 修改 _getUserTier 函数
├─ 添加查询函数 (getNodeTierDetails, getUserTierBreakdown)
└─ 单元测试（不涉及提前支取）

阶段3: 提前支取功能 (3-4天)
├─ 实现 withdrawInterest 函数
├─ 修改 unstake 函数（减去 withdrawnProfit）
├─ 添加查询函数 (canWithdrawInterest)
└─ 单元测试（不涉及节点等级）

阶段4: 集成测试 (2-3天)
├─ 组合场景测试（节点等级 + 提前支取）
├─ 边界条件测试
├─ Gas 优化测试
└─ 审计准备

阶段5: 部署上线 (1-2天)
├─ 测试网部署
├─ 功能验证
├─ 主网部署
└─ 监控设置
```

### 6.2 关键代码审查点

```
必须审查的代码：
□ unstake 是否正确减去 withdrawnProfit？
□ _getUserTier 的节点等级逻辑是否正确？
□ withdrawInterest 是否正确记录 withdrawnProfit？
□ 团队奖励分配是否受节点等级影响？
□ Preacher 检查是否在所有必要位置？
□ 事件是否完整记录所有关键操作？
□ 是否存在重入攻击风险？
□ 是否存在整数溢出风险？（Solidity 0.8+ 自动检查）
```

### 6.3 部署前检查清单

```
数据结构：
□ Record 结构体已正确修改（添加 withdrawnProfit）
□ NodeTierRecord 已定义并添加到 mapping
□ 存储布局兼容性已验证

功能实现：
□ withdrawInterest 函数已实现并测试
□ unstake 函数已修改（减去 withdrawnProfit）
□ _getUserTier 函数已修改（节点等级逻辑）
□ 所有管理函数已实现（setTierManager, setNodeTier 等）

测试覆盖：
□ 节点等级单独测试通过
□ 提前支取单独测试通过
□ 组合场景测试通过
□ 边界条件测试通过
□ Gas 测试通过

安全审查：
□ 代码审查完成
□ 重入攻击检查通过
□ 权限控制检查通过
□ 事件记录完整
□ 错误处理完善

文档和监控：
□ 用户文档更新
□ 技术文档更新
□ 监控仪表盘配置
□ 告警规则设置
```

---

## 七、结论

### 7.1 冲突总结

| 冲突类型 | 是否存在 | 严重程度 | 解决方案 |
|---------|---------|---------|---------|
| 数据结构冲突 | ❌ 无 | - | 独立修改，无冲突 |
| 函数调用链冲突 | ✅ 有 | 🟢 低 | 逻辑上兼容，无需特殊处理 |
| 团队奖励计算冲突 | ❌ 无 | - | 数学验证通过 |
| Preacher 检查冲突 | ❌ 无 | - | withdrawInterest 不影响本金 |
| 复利计算冲突 | ❌ 无 | - | 两功能都不修改核心公式 |

### 7.2 必须协调的修改

1. **unstake 函数修改**（🔴 必须）
   - 提前支取功能要求：减去 withdrawnProfit
   - 节点等级功能要求：使用修改后的 _getUserTier
   - 解决方案：统一在 unstake 中实现两个修改

2. **Record 结构体修改**（🔴 必须）
   - 提前支取功能要求：添加 withdrawnProfit 字段
   - 节点等级功能：不修改 Record
   - 解决方案：按提前支取功能的要求修改

3. **_getUserTier 函数修改**（🔴 必须）
   - 节点等级功能要求：增加 MAX(自然等级, 节点等级) 逻辑
   - 提前支取功能：会间接受影响（通过团队奖励分配）
   - 解决方案：按节点等级功能的要求修改

### 7.3 最终评估

**总体风险等级**：🟡 中等（需要协调设计，但无致命冲突）

**可行性评估**：✅ **可以同时实施**

**关键前提**：
1. ✅ 合约尚未部署，或可以重新部署
2. ✅ unstake 函数正确实现 withdrawnProfit 减法
3. ✅ 充分的测试覆盖（单元测试 + 集成测试）
4. ✅ 代码审查和安全审计

**预期效果**：
- 用户体验：★★★★★（节点等级保障 + 灵活提取）
- 系统安全：★★★★☆（需监控流动性和团队奖励）
- 实现难度：★★★☆☆（中等，需要协调两个功能）
- Gas 成本：★★★★☆（增加 < 10%，可接受）

**推荐做法**：
1. 先完成数据结构修改
2. 并行开发两个功能（分别测试）
3. 集成测试覆盖组合场景
4. 审计后再部署主网

---

**文档版本**: v1.0
**创建日期**: 2025-10-14
**作者**: Claude Code
**状态**: ✅ 分析完成，建议同时实施
