# 质押系统全局供应量管理

## 概述

本文档说明 SYI 质押合约中关于全局质押总数（totalSupply）的控制机制和管理功能。

---

## 一、全局质押总数追踪

### 1.1 核心变量：`totalSupply`

**位置**：`StakingBase.sol:105`

```solidity
uint256 public totalSupply;
```

**说明**：
- 记录所有用户质押的 sSYI 代币总量
- 与实际质押的 SYI 代币 1:1 对应
- 公开可读，任何人都可以查询

### 1.2 供应量修改机制

供应量通过 `_update` 内部函数修改（`StakingBase.sol:1060-1076`）：

```solidity
function _update(address from, address to, uint256 value) internal {
    if (from == address(0)) {
        // 铸造：增加供应量
        balances[to] += value;
        totalSupply += value;
        emit Transfer(address(0), to, value);
        return;
    }

    if (to == address(0)) {
        // 销毁：减少供应量
        balances[from] -= value;
        totalSupply -= value;
        emit Transfer(from, address(0), value);
        return;
    }

    revert("Transfers between users not supported");
}
```

**特点**：
- 只支持铸造（mint）和销毁（burn）操作
- 不支持用户之间的转账
- 确保 sSYI 代币只能通过质押产生，解除质押时销毁

### 1.3 供应量变化的触发点

#### ✅ 增加供应量（质押时）

**位置**：`StakingBase.sol:1166`

```solidity
function _mintStakeRecord(...) private {
    // ... 其他逻辑
    _update(address(0), sender, _amount);  // 铸造 sSYI
    // ...
}
```

**触发条件**：
- 用户调用 `stake()` 函数成功质押 SYI
- 合约为用户铸造等量的 sSYI 代币
- totalSupply 自动增加

#### ✅ 减少供应量（解除质押时）

**位置**：`StakingBase.sol:1194`

```solidity
function _burn(uint256 index) private returns (uint256 reward, uint256 amount) {
    // ... 验证逻辑
    _update(sender, address(0), amount);  // 销毁 sSYI
    // ...
}
```

**触发条件**：
- 用户调用 `unstake()` 函数解除质押
- 合约销毁用户的 sSYI 代币
- totalSupply 自动减少

---

## 二、手动增加供应量的功能

### 2.1 结论：❌ 不存在

**分析结果**：
- **没有** `mint()` 函数供管理员直接铸造代币
- **没有** `increaseSupply()` 或类似的管理员函数
- **没有** 任何手动修改 `totalSupply` 的后门

### 2.2 设计原因

这是一个 **安全且合理** 的设计：

1. **1:1 对应原则**
   - sSYI 代币必须与实际质押的 SYI 1:1 对应
   - 防止凭空增发导致的会计错误

2. **防止滥用**
   - 避免管理员恶意增发代币
   - 确保供应量完全由用户质押行为决定

3. **透明性**
   - 供应量变化完全可追溯
   - 每次增减都会触发 `Transfer` 事件

---

## 三、供应量监控与限制机制

### 3.1 历史供应量记录

**变量**：`t_supply`（`StakingBase.sol:112`）

```solidity
IStaking.RecordTT[] public t_supply;

struct RecordTT {
    uint40 stakeTime;    // 时间戳
    uint160 tamount;     // 当时的 totalSupply
}
```

**用途**：
- 记录每次质押时的供应量快照
- 用于计算网络流入速度

### 3.2 网络流入速度计算

**函数**：`getRecentNetworkInflow()`（`StakingBase.sol:992-1017`）

```solidity
function getRecentNetworkInflow() public view returns (uint256 recentInflow) {
    uint256 cutoffTime = block.timestamp - NETWORK_CHECK_INTERVAL;  // 1分钟前
    // ... 计算最近1分钟的流入量
    return totalSupply - previousTotalSupply;
}
```

**作用**：
- 统计最近 1 分钟内的净流入量
- 用于动态调整质押限额

### 3.3 质押限额控制

**函数**：`maxStakeAmount()`（`StakingBase.sol:1019-1030`）

```solidity
function maxStakeAmount() public view returns (uint256 maxAmount) {
    uint256 recentInflow = getRecentNetworkInflow();
    uint112 poolReserveUsdt = SYI.getUSDTReserve();
    uint256 onePercentOfPool = poolReserveUsdt / 100;

    if (recentInflow > onePercentOfPool) {
        return 0;  // 流入过快时暂停质押
    } else {
        uint256 availableCapacity = onePercentOfPool - recentInflow;
        return _min256(availableCapacity, MAX_STAKE_LIMIT);  // 最多1000 SYI
    }
}
```

**逻辑**：
1. 计算流动性池 USDT 储备的 1%
2. 如果最近流入 > 1% 储备，则暂停质押
3. 否则限制单次质押不超过 `min(剩余容量, 1000 SYI)`

**目的**：
- 防止短时间内大量质押冲击价格
- 保护流动性池稳定性

### 3.4 用户总质押限额

**常量**：`MAX_USER_TOTAL_STAKE`（`StakingBase.sol:61`）

```solidity
uint256 internal constant MAX_USER_TOTAL_STAKE = 10000 ether;  // 单用户累计限额
```

**验证**：`_validateStakeParameters()`（`StakingBase.sol:1478-1489`）

```solidity
function _validateStakeParameters(uint160 _amount, uint8 _stakeIndex) private view {
    uint256 userCurrentTotal = principalBalance(msg.sender);
    if (userCurrentTotal + _amount > MAX_USER_TOTAL_STAKE) {
        revert ExceedsUserTotalStakeLimit();
    }
}
```

**限制**：
- 单个用户累计质押不超过 10,000 SYI
- 多次质押累计计算

---

## 四、管理员权限

### 4.1 紧急提取功能

**函数**：`emergencyWithdrawSYI` / `emergencyWithdrawUSDT`（`StakingBase.sol:1724-1736`）

```solidity
function emergencyWithdrawSYI(address to, uint256 _amount) external onlyOwner {
    SYI.transfer(to, _amount);
}

function emergencyWithdrawUSDT(address to, uint256 _amount) external onlyOwner {
    IERC20(USDT).transfer(to, _amount);
}
```

**注意**：
- ⚠️ 这些函数只能提取代币余额
- ⚠️ **不会修改** `totalSupply` 或用户的质押记录
- 用于紧急情况下转移合约中的剩余代币

### 4.2 设置 SYI 代币地址

**函数**：`setSYI()`（`StakingBase.sol:1717-1722`）

```solidity
function setSYI(address _syi) external onlyOwner {
    require(_syi != address(0), "SYI address cannot be zero");
    SYI = ISYI(_syi);
    SYI.approve(address(ROUTER), type(uint256).max);
    emit SYIContractSet(_syi);
}
```

**用途**：
- 初始化或更新 SYI 代币合约地址
- 不影响供应量

---

## 五、总结

### 5.1 核心发现

| 功能 | 是否存在 | 说明 |
|------|---------|------|
| 追踪全局质押总数 | ✅ 是 | `totalSupply` 变量 |
| 手动增加供应量 | ❌ 否 | 仅通过正常质押增加 |
| 手动减少供应量 | ❌ 否 | 仅通过解除质押减少 |
| 供应量历史记录 | ✅ 是 | `t_supply` 数组 |
| 流入速度监控 | ✅ 是 | `getRecentNetworkInflow()` |
| 动态质押限额 | ✅ 是 | `maxStakeAmount()` |
| 用户累计限额 | ✅ 是 | `MAX_USER_TOTAL_STAKE` (10,000) |

### 5.2 安全性评估

**优点**：
- ✅ 供应量完全由用户行为决定，无法人为操控
- ✅ sSYI 与 SYI 严格 1:1 对应
- ✅ 多层限额机制防止恶意行为
- ✅ 历史记录可追溯

**潜在风险**：
- ⚠️ `emergencyWithdrawSYI` 可能破坏供应平衡（如果滥用）
- ⚠️ 但不会影响 `totalSupply` 的准确性

### 5.3 与 OLA 系统的对比

与原 OLA 质押系统的主要区别：

| 特性 | OLA Staking | SYI Staking |
|------|-------------|-------------|
| 买卖税 | ✅ 3% | ❌ 无 |
| 盈利税 | ✅ 25% | ❌ 无 |
| LP质押 | ✅ 有 | ❌ 移除 |
| 随时提取收益 | ❌ 到期提取 | ✅ 支持 `withdrawInterest()` |
| 手动增发 | ❌ 无 | ❌ 无 |
| 黑白名单 | ✅ 有 | ❌ 移除（准备上交易所）|

---

## 六、相关代码位置

| 功能 | 文件 | 行号 |
|------|------|------|
| totalSupply 定义 | StakingBase.sol | 105 |
| _update 函数 | StakingBase.sol | 1060-1076 |
| 质押铸造 | StakingBase.sol | 1166 |
| 解除质押销毁 | StakingBase.sol | 1194 |
| 历史记录 | StakingBase.sol | 112, 1144-1147 |
| 流入速度计算 | StakingBase.sol | 992-1017 |
| 质押限额 | StakingBase.sol | 1019-1030 |
| 紧急提取 | StakingBase.sol | 1724-1736 |

---

## 七、查询供应量的方法

### 7.1 链上查询

```javascript
// 使用 ethers.js
const staking = await ethers.getContractAt("Staking", stakingAddress);

// 查询当前总供应量
const totalSupply = await staking.totalSupply();
console.log("Total sSYI Supply:", ethers.formatEther(totalSupply));

// 查询最近流入量
const recentInflow = await staking.getRecentNetworkInflow();
console.log("Recent Inflow (1min):", ethers.formatEther(recentInflow));

// 查询当前质押限额
const maxStake = await staking.maxStakeAmount();
console.log("Max Stake Amount:", ethers.formatEther(maxStake));
```

### 7.2 查询用户余额

```javascript
// 查询用户的 sSYI 余额（当前价值，包含收益）
const balance = await staking.balanceOf(userAddress);
console.log("User Balance:", ethers.formatEther(balance));

// 查询用户的本金（不含收益）
const principal = await staking.principalBalance(userAddress);
console.log("User Principal:", ethers.formatEther(principal));

// 查询用户的累计收益
const interest = await staking.earnedInterest(userAddress);
console.log("User Interest:", ethers.formatEther(interest));
```

---

## 八、建议

### 8.1 监控建议

建议在前端或后台监控以下指标：

1. **totalSupply 趋势**：监控供应量增长速度
2. **recentInflow**：监控短期流入异常
3. **maxStakeAmount**：提醒用户当前可质押额度
4. **用户余额分布**：统计大户和小户比例

### 8.2 风险提示

对于管理员：
- ⚠️ 谨慎使用 `emergencyWithdrawSYI`
- ⚠️ 如果提取了过多 SYI，可能导致用户无法正常解除质押
- ⚠️ 建议只在紧急情况下使用，并确保不影响用户权益

---

## 结论

**SYI 质押系统不支持手动增加全局供应量**，这是一个安全且合理的设计。所有供应量变化都必须通过正常的质押/解除质押流程，确保了系统的透明性和可信度。

---

## 附录：全局质押总量控制机制简明说明

### ✅ 是的，按每分钟计算！

**控制原理**：

```
每次用户质押前，系统会检查：

1️⃣ 查询 SYI/USDT 流动性池的 USDT 储备量
2️⃣ 计算 1% 作为安全阈值
3️⃣ 统计最近 1 分钟内的质押流入量
4️⃣ 判断：
   - 如果 流入量 > 1% 储备  →  暂停质押（返回 0）
   - 否则  →  允许质押，但限制单次不超过 min(剩余容量, 1000 SYI)
```

### 🎯 具体例子

假设当前流动性池有 **100,000 USDT**：

| 最近1分钟流入 | 1%阈值 | 是否允许质押 | 单次最大额度 |
|-------------|-------|------------|------------|
| 0 SYI | 1,000 USDT | ✅ 允许 | 1,000 SYI |
| 500 SYI | 1,000 USDT | ✅ 允许 | 500 SYI (剩余容量) |
| 1,000 SYI | 1,000 USDT | ✅ 允许 | 1,000 SYI (边界值) |
| 1,200 SYI | 1,000 USDT | ❌ **暂停** | 0 SYI (超限) |

### 📍 关键代码

**位置**：`StakingBase.sol:1019-1030`

```solidity
function maxStakeAmount() public view returns (uint256 maxAmount) {
    uint256 recentInflow = getRecentNetworkInflow();  // 最近1分钟流入
    uint112 poolReserveUsdt = SYI.getUSDTReserve();   // 池子USDT储备
    uint256 onePercentOfPool = poolReserveUsdt / 100; // 1%阈值

    if (recentInflow > onePercentOfPool) {
        return 0;  // ❌ 暂停质押
    } else {
        uint256 availableCapacity = onePercentOfPool - recentInflow;
        return _min256(availableCapacity, MAX_STAKE_LIMIT);  // 最多1000 SYI
    }
}
```

### 🎭 设计目的

1. **防止价格冲击**：限制短时间内大量买入 SYI（质押时需要买 SYI）
2. **保护流动性**：确保池子深度不被快速消耗
3. **动态调整**：流入量每分钟更新，冷却后自动恢复

### ⚠️ 注意事项

- 时间窗口：**1 分钟**（`NETWORK_CHECK_INTERVAL = 1 minutes`）
- 如果被限制：等待 1 分钟后，限额会自动恢复
- 即使全局有限制，单用户累计仍不能超过 **10,000 SYI**

---

## 附录2：前端显示单笔限额的完整逻辑

### 🎨 前端需要展示的限额

用户单笔质押限额应该取以下**4个值的最小值**：

```javascript
// 1️⃣ 全局限额（已自动考虑1%阈值和1分钟流入）
const globalMaxAmount = await staking.maxStakeAmount();

// 2️⃣ 用户剩余额度（单用户累计上限10,000 SYI）
const userRemaining = await staking.getRemainingStakeCapacity(userAddress);

// 3️⃣ 用户钱包 USDT 余额
const usdtBalance = await usdt.balanceOf(userAddress);

// 4️⃣ 用户钱包 USDT 授权额度（给 Staking 合约）
const usdtAllowance = await usdt.allowance(userAddress, stakingAddress);

// 🎯 最终显示的单笔限额
const finalMaxAmount = Math.min(
    globalMaxAmount,
    userRemaining,
    usdtBalance,
    usdtAllowance
);
```

### 📊 推荐的前端展示方案

**方案1：简洁版（只显示最终限额）**

```
┌─────────────────────────────────┐
│ 单笔最大质押额                    │
│ 500 SYI                         │
│                                 │
│ [输入金额]  [最大]               │
│                                 │
│ [质押]                          │
└─────────────────────────────────┘
```

**方案2：详细版（显示限制原因）**

```
┌─────────────────────────────────────────┐
│ 单笔最大质押额: 500 SYI                  │
│                                         │
│ 限制详情：                               │
│ • 全局限额: 500 SYI ⚠️ (最近流入较多)    │
│ • 您的剩余额度: 8,000 SYI ✅             │
│ • 钱包余额: 1,000 USDT ✅                │
│                                         │
│ [输入金额]  [最大]                       │
│                                         │
│ [质押]                                  │
└─────────────────────────────────────────┘
```

**方案3：动态提示版（当限额变化时提示）**

```
┌─────────────────────────────────────────┐
│ 单笔最大质押额: 0 SYI ❌                 │
│                                         │
│ ⚠️ 当前网络质押流入过快，暂时限制质押      │
│ 预计 42 秒后恢复正常                     │
│                                         │
│ [刷新限额]                               │
└─────────────────────────────────────────┘
```

### 🔄 实时更新建议

**推荐做法**：

1. **页面加载时**：立即查询一次限额
2. **每30秒**：自动刷新限额（因为1分钟窗口会变化）
3. **用户输入时**：实时验证输入是否超限
4. **质押前**：再次验证限额（防止用户输入后限额变化）

```javascript
// 实时更新限额的例子
useEffect(() => {
    const updateLimits = async () => {
        const globalMax = await staking.maxStakeAmount();
        const userRemaining = await staking.getRemainingStakeCapacity(userAddress);
        const usdtBalance = await usdt.balanceOf(userAddress);

        setMaxAmount(Math.min(globalMax, userRemaining, usdtBalance));
    };

    // 初始加载
    updateLimits();

    // 每30秒刷新
    const interval = setInterval(updateLimits, 30000);

    return () => clearInterval(interval);
}, [userAddress]);
```

### ⚡ 错误处理

当用户质押失败时，根据错误类型显示不同提示：

| 错误原因 | 合约错误 | 前端提示 |
|---------|---------|---------|
| 超过全局限额 | `ExceedsMaxStakeAmount` | "当前网络流入较多，请稍后再试或减少金额" |
| 超过用户累计限额 | `ExceedsUserTotalStakeLimit` | "您的累计质押已达上限 10,000 SYI" |
| 无效的档期 | `InvalidStakeIndex` | "请选择有效的质押档期" |
| 未绑定推荐人 | `MustBindReferral` | "请先绑定推荐人" |

### 💡 用户体验优化

**当限额为0时**：

```javascript
if (maxAmount === 0) {
    // 查询流动性池信息，预估恢复时间
    const recentInflow = await staking.getRecentNetworkInflow();
    const poolReserve = await syi.getUSDTReserve();
    const onePercent = poolReserve / 100n;

    if (recentInflow > onePercent) {
        showMessage({
            type: 'warning',
            title: '暂时限制质押',
            message: '最近1分钟内质押流入较多，请稍后再试',
            countdown: 60 // 显示倒计时
        });
    }
}
```

**当用户剩余额度不足时**：

```javascript
if (userRemaining < 100) {
    showMessage({
        type: 'info',
        title: '提示',
        message: `您的剩余质押额度仅为 ${userRemaining} SYI`,
        action: '查看我的质押记录'
    });
}
```

### 📋 完整的前端查询代码示例

```javascript
async function getStakingLimits(userAddress) {
    // 1. 查询全局限额（包含1%阈值检查）
    const globalMaxAmount = await staking.maxStakeAmount();
    const globalMaxAmountFormatted = ethers.formatEther(globalMaxAmount);

    // 2. 查询用户剩余额度
    const userRemaining = await staking.getRemainingStakeCapacity(userAddress);
    const userRemainingFormatted = ethers.formatEther(userRemaining);

    // 3. 查询用户USDT余额
    const usdtBalance = await usdt.balanceOf(userAddress);
    const usdtBalanceFormatted = ethers.formatEther(usdtBalance);

    // 4. 查询授权额度
    const allowance = await usdt.allowance(userAddress, stakingAddress);
    const allowanceFormatted = ethers.formatEther(allowance);

    // 5. 查询详细信息（用于展示）
    const recentInflow = await staking.getRecentNetworkInflow();
    const totalSupply = await staking.totalSupply();

    // 6. 计算最终限额
    const finalMax = Math.min(
        parseFloat(globalMaxAmountFormatted),
        parseFloat(userRemainingFormatted),
        parseFloat(usdtBalanceFormatted),
        parseFloat(allowanceFormatted)
    );

    return {
        finalMaxAmount: finalMax,
        details: {
            global: parseFloat(globalMaxAmountFormatted),
            userRemaining: parseFloat(userRemainingFormatted),
            usdtBalance: parseFloat(usdtBalanceFormatted),
            allowance: parseFloat(allowanceFormatted)
        },
        networkInfo: {
            recentInflow: ethers.formatEther(recentInflow),
            totalSupply: ethers.formatEther(totalSupply)
        },
        limitingFactor: finalMax === parseFloat(globalMaxAmountFormatted)
            ? 'global'
            : finalMax === parseFloat(userRemainingFormatted)
            ? 'user_limit'
            : finalMax === parseFloat(usdtBalanceFormatted)
            ? 'balance'
            : 'allowance'
    };
}
```

### 🎯 总结

**是的，前端显示单笔限额时必须考虑1%阈值！**

✅ **正确做法**：
```javascript
const maxAmount = await staking.maxStakeAmount(); // 已包含1%阈值检查
```

❌ **错误做法**：
```javascript
const maxAmount = 1000; // 写死为1000 SYI，忽略动态限制
```

**关键点**：
- `maxStakeAmount()` 函数已经自动计算了1%阈值、1分钟流入量
- 前端只需调用这个函数，不需要自己重复计算
- 但需要结合用户剩余额度、钱包余额等其他限制
- 建议每30秒刷新一次，因为限额会动态变化
