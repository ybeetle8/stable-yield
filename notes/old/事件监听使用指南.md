# SYI-Staking 事件监听使用指南

## 📚 相关文档

- **事件说明文档**：[质押合约事件说明.md](./质押合约事件说明.md)
- **合约接口**：`contracts/SYI-Staking/interfaces/IStaking.sol`
- **合约实现**：`contracts/SYI-Staking/abstract/StakingBase.sol`

---

## 🚀 快速开始

### 前置条件

1. **启动 Fork 节点**（在第一个终端窗口）：

```bash
npx hardhat node --fork https://binance.llamarpc.com --fork-block-number 63482920
```

> ⚠️ **重要**：保持此终端窗口运行，不要关闭！

---

### 方法一：实时监听事件（推荐）

#### 步骤 1：启动事件监听器（第二个终端窗口）

```bash
npm run monitor-events
```

或

```bash
npx hardhat run scripts/monitorStakingEvents.js --network localhost
```

**功能说明：**
- ✅ 自动查询最近 100 个区块的历史事件
- ✅ 实时监听所有新事件
- ✅ 以中文格式化输出事件详情
- ✅ 支持 19 种事件类型

**输出示例：**
```
================================================================================
📌 事件：质押成功 (Staked)
================================================================================
用户地址：     0x1234...5678 (0x1234...5678)
质押金额：     500.0 USDT
质押时间：     2025-10-14 15:30:45
记录索引：     #0
质押周期：     180天 0小时
区块高度：     12345678
交易哈希：     0xabcd...efgh
================================================================================
```

#### 步骤 2：触发测试事件（第三个终端窗口）

```bash
npm run test-events
```

或

```bash
npx hardhat run scripts/testStakingEvents.js --network localhost
```

**测试内容：**
1. ✅ 绑定推荐关系（4个用户）
2. ✅ 绑定好友关系
3. ✅ 执行质押操作（4笔不同档位）
4. ✅ 中途提取利息
5. ✅ 设置节点等级
6. ✅ 批量设置节点等级
7. ✅ 更新费用接收地址

**触发的事件：**
- `BindReferral` - 绑定推荐人
- `BindFriend` - 绑定好友
- `Staked` - 质押成功
- `Transfer` - sSYI 铸造
- `InterestWithdrawn` - 中途提息
- `CompoundInterestReset` - 复利重置
- `RedemptionFeeCollected` - 赎回手续费
- `NodeTierSet` - 设置节点等级
- `NodeTierBatchSet` - 批量设置等级
- `FeeRecipientUpdated` - 更新费用接收地址

---

### 方法二：脚本内集成监听

在你自己的脚本中集成事件监听：

```javascript
const { ethers } = require("hardhat");

async function main() {
  const staking = await ethers.getContractAt("Staking", stakingAddress);

  // 监听质押事件
  staking.on("Staked", (user, amount, timestamp, index, stakeTime) => {
    console.log(`用户 ${user} 质押了 ${ethers.formatUnits(amount, 18)} USDT`);
  });

  // 监听提取事件
  staking.on("WithdrawalCompleted", (user, stakeIndex, ...args) => {
    console.log(`用户 ${user} 完成提取，质押索引 #${stakeIndex}`);
  });

  // 执行操作...
  await staking.connect(user).stake(amount, stakeIndex);
}
```

---

## 📊 支持的事件列表

### 核心业务事件（5个）

| 事件名 | 说明 | 触发时机 |
|--------|------|---------|
| `Staked` | 质押成功 | 用户成功质押 USDT |
| `WithdrawalCompleted` | 完整提取 | 质押到期后完整提取 |
| `InterestWithdrawn` | 中途提息 | 质押未到期时提取利息 |
| `CompoundInterestReset` | 复利重置 | 中途提息后重置复利起点 |
| `RewardPaid` | 奖励支付 | Legacy 事件，已被 WithdrawalCompleted 替代 |

### 推荐与好友系统（5个）

| 事件名 | 说明 | 触发时机 |
|--------|------|---------|
| `BindReferral` | 绑定推荐人 | 用户调用 lockReferral() |
| `BindFriend` | 绑定好友 | 用户调用 lockFriend() |
| `StrictDifferentialRewardPaid` | 差额奖励 | 团队成员领取差额奖励 |
| `TeamRewardDistributionCompleted` | 分发完成 | 一次完整的团队奖励分发 |
| `PreacherCheckFailed` | 资格不足 | 用户未满足 Preacher 条件 |

### 系统管理（3个）

| 事件名 | 说明 | 触发时机 |
|--------|------|---------|
| `Transfer` | 代币转账 | sSYI 铸造或销毁 |
| `SYIContractSet` | 设置合约 | Owner 设置 SYI 代币合约 |
| `StakingRatesUpdated` | 利率更新 | 合约初始化时设置利率 |

### 费用相关（2个）

| 事件名 | 说明 | 触发时机 |
|--------|------|---------|
| `RedemptionFeeCollected` | 收取手续费 | 用户 unstake 或 withdrawInterest |
| `FeeRecipientUpdated` | 更新接收方 | Owner 更新费用接收地址 |

### 节点等级管理（4个）

| 事件名 | 说明 | 触发时机 |
|--------|------|---------|
| `TierManagerUpdated` | 管理员更新 | Owner 设置等级管理员 |
| `NodeTierSet` | 设置等级 | TierManager 为用户设置等级 |
| `NodeTierRemoved` | 移除等级 | TierManager 移除用户等级 |
| `NodeTierBatchSet` | 批量设置 | TierManager 批量设置等级 |

**总计：19 个事件**

---

## 🔍 查询历史事件

### 查询特定用户的质押记录

```javascript
const filter = staking.filters.Staked(userAddress);
const events = await staking.queryFilter(filter, fromBlock, toBlock);

for (const event of events) {
  console.log(`质押时间：${event.args.timestamp}`);
  console.log(`质押金额：${ethers.formatUnits(event.args.amount, 18)} USDT`);
}
```

### 查询所有团队奖励分发

```javascript
const filter = staking.filters.TeamRewardDistributionCompleted();
const events = await staking.queryFilter(filter, fromBlock, toBlock);

for (const event of events) {
  const totalDistributed = event.args.totalDistributed;
  console.log(`分发金额：${ethers.formatUnits(totalDistributed, 18)} USDT`);
}
```

### 查询节点等级变更

```javascript
// 查询某用户的等级设置记录
const setFilter = staking.filters.NodeTierSet(userAddress);
const setEvents = await staking.queryFilter(setFilter, fromBlock, toBlock);

// 查询某用户的等级移除记录
const removeFilter = staking.filters.NodeTierRemoved(userAddress);
const removeEvents = await staking.queryFilter(removeFilter, fromBlock, toBlock);
```

---

## 💡 使用技巧

### 1. 过滤特定事件

```javascript
// 只监听特定用户的质押事件
const filter = staking.filters.Staked(userAddress);
staking.on(filter, (user, amount, timestamp, index, stakeTime, event) => {
  console.log("特定用户质押了！");
});
```

### 2. 一次性监听（once）

```javascript
// 只监听一次，触发后自动取消
staking.once("Staked", (user, amount) => {
  console.log("第一次质押触发！");
});
```

### 3. 移除监听器

```javascript
const handler = (user, amount) => {
  console.log("质押事件！");
};

staking.on("Staked", handler);

// 移除特定监听器
staking.off("Staked", handler);

// 移除所有监听器
staking.removeAllListeners("Staked");
```

### 4. 限制查询区块范围

```javascript
// 分批查询避免超时
const batchSize = 1000;
for (let i = startBlock; i < endBlock; i += batchSize) {
  const events = await staking.queryFilter(
    filter,
    i,
    Math.min(i + batchSize, endBlock)
  );
  // 处理事件...
}
```

---

## ⚠️ 注意事项

### 1. Indexed 参数限制

- 每个事件最多 3 个 `indexed` 参数
- 只有 indexed 参数可以被过滤
- 示例：`Staked` 事件中只有 `user` 是 indexed

### 2. 区块范围限制

- 查询历史事件时注意区块范围限制
- BSC 主网单次查询建议不超过 5000 个区块
- 可以分批查询避免超时

### 3. 事件监听内存

- 长时间监听可能占用内存
- 生产环境建议定期重启监听器
- 或者使用数据库存储历史事件

### 4. 网络延迟

- 事件触发可能有 1-2 个区块的延迟
- 使用 `event.blockNumber` 确认实际区块高度
- 监听时等待交易确认（`await tx.wait()`）

---

## 🐛 常见问题

### Q1: 监听器没有收到事件？

**解决方案：**
1. 确认 Hardhat 节点正在运行
2. 检查合约地址是否正确（deployed-addresses.json）
3. 确认事件名称拼写正确
4. 使用 `queryFilter` 检查历史事件是否存在

### Q2: 查询历史事件超时？

**解决方案：**
1. 减小区块范围（fromBlock - toBlock）
2. 分批查询
3. 使用 Archive Node（支持更大范围查询）

### Q3: 事件参数解析错误？

**解决方案：**
1. 确认合约 ABI 是否最新（重新编译）
2. 检查参数类型匹配
3. 使用 `event.args` 访问参数而不是位置索引

### Q4: 如何在生产环境使用？

**建议：**
1. 使用 WebSocket 连接（更稳定）
2. 配置重连机制
3. 使用 The Graph 或 Moralis 等索引服务
4. 存储事件到数据库

---

## 📝 示例：完整的事件监听服务

```javascript
const { ethers } = require("hardhat");

class StakingEventMonitor {
  constructor(stakingAddress) {
    this.stakingAddress = stakingAddress;
    this.staking = null;
    this.listeners = new Map();
  }

  async start() {
    this.staking = await ethers.getContractAt("Staking", this.stakingAddress);

    // 注册所有监听器
    this.registerAllListeners();

    console.log("✅ 事件监听器启动成功");
  }

  registerAllListeners() {
    // 质押事件
    this.on("Staked", this.handleStaked.bind(this));
    this.on("WithdrawalCompleted", this.handleWithdrawal.bind(this));
    this.on("InterestWithdrawn", this.handleInterestWithdrawn.bind(this));

    // 推荐系统
    this.on("BindReferral", this.handleBindReferral.bind(this));
    this.on("TeamRewardDistributionCompleted", this.handleTeamReward.bind(this));

    // 更多事件...
  }

  on(eventName, handler) {
    this.staking.on(eventName, handler);
    this.listeners.set(eventName, handler);
  }

  handleStaked(user, amount, timestamp, index, stakeTime) {
    console.log(`[质押] ${user} 质押了 ${ethers.formatUnits(amount, 18)} USDT`);
    // 存储到数据库、发送通知等...
  }

  handleWithdrawal(user, stakeIndex, ...args) {
    console.log(`[提取] ${user} 完成提取 #${stakeIndex}`);
    // 处理提取逻辑...
  }

  handleInterestWithdrawn(user, stakeIndex, profitAmount, ...args) {
    console.log(`[提息] ${user} 提取利息 ${ethers.formatUnits(profitAmount, 18)} SYI`);
    // 处理提息逻辑...
  }

  handleBindReferral(user, parent) {
    console.log(`[推荐] ${user} 绑定推荐人 ${parent}`);
    // 更新推荐关系树...
  }

  handleTeamReward(...args) {
    console.log(`[团队奖励] 分发完成`);
    // 统计团队奖励...
  }

  async stop() {
    // 移除所有监听器
    for (const [eventName, handler] of this.listeners) {
      this.staking.off(eventName, handler);
    }
    this.listeners.clear();
    console.log("❌ 事件监听器已停止");
  }

  async queryHistory(eventName, fromBlock, toBlock) {
    const filter = this.staking.filters[eventName]();
    return await this.staking.queryFilter(filter, fromBlock, toBlock);
  }
}

// 使用示例
async function main() {
  const monitor = new StakingEventMonitor(stakingAddress);
  await monitor.start();

  // 查询历史
  const events = await monitor.queryHistory("Staked", 0, "latest");
  console.log(`找到 ${events.length} 个历史质押事件`);

  // 保持运行
  await new Promise(() => {});
}

main();
```

---

## 📞 技术支持

如有问题，请参考：
- [合约事件说明文档](./质押合约事件说明.md)
- [Hardhat 官方文档](https://hardhat.org/hardhat-runner/docs/advanced/using-viem)
- [Ethers.js 事件文档](https://docs.ethers.org/v6/api/contract/#ContractEvent)

---

**最后更新：2025-10-14**
