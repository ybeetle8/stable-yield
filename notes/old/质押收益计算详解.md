# SYI 质押系统收益计算详解

## 一、收益计算概览

### 1.1 质押档位与收益率

SYI 质押系统支持 4 个质押档位，每个档位有固定的质押期限和日利率：

| 档位 | 质押期限 | 日利率 | 预期总收益率 | stakeIndex |
|------|---------|--------|------------|------------|
| 1天档 | 1 天 | 0.3% | 0.3% | 0 |
| 30天档 | 30 天 | 0.6% | 19.88% | 1 |
| 90天档 | 90 天 | 0.9% | 123.44% | 2 |
| 180天档 | 180 天 | 1.5% | 1536.14% | 3 |

**注**:
- 档位已从原来的 1/7/15/30 天调整为 1/30/90/180 天
- 每日复利：总收益 = (1 + 日利率)^天数 - 1
- ⚠️ **高收益警告**: 90天档和180天档的收益率极高，需要确保代币经济模型能够支撑

### 1.2 核心特性

✅ **每日复利**: 系统采用每日复利计算，不是简单利息
✅ **实时计算**: 收益随时间实时增长，无需手动触发
✅ **高精度**: 使用 `@prb/math` 库的 UD60x18 进行 60 位定点数运算
✅ **封顶机制**: 收益最多计算到质押期满，超过期限不再增长

---

## 二、复利计算原理

### 2.1 复利公式

质押收益采用标准的**复利公式**：

```
最终金额 = 本金 × (1 + r)^n
```

其中：
- **本金**: 用户质押的 USDT 金额（转换为等值 sSYI）
- **r**: 每日复利率（日利率）
- **n**: 复利周期数（质押天数）

### 2.2 代码实现

核心计算函数位于 `StakingBase.sol:1167-1196`：

```solidity
function _calculateStakeReward(
    IStaking.Record storage stakeRecord
) private view returns (uint256 currentReward) {
    // 1. 获取本金
    UD60x18 principalAmount = ud(stakeRecord.amount);

    // 2. 计算质押时长（秒）
    uint40 stakingDuration = uint40(block.timestamp) - stakeRecord.stakeTime;

    // 3. 封顶到质押期限
    stakingDuration = _min40(
        stakingDuration,
        uint40(getStakePeriod(stakeRecord.stakeIndex))
    );

    // 4. 计算复利周期数（天数）
    uint256 compoundPeriods = stakingDuration / getCompoundTimeUnit(); // 1 days

    // 5. 应用复利公式: 本金 * (利率)^天数
    UD60x18 baseInterestRate = ud(rates[stakeRecord.stakeIndex]);
    UD60x18 compoundedAmount = principalAmount.mul(
        baseInterestRate.powu(compoundPeriods)
    );

    currentReward = UD60x18.unwrap(compoundedAmount);
}
```

---

## 三、利率参数解析

### 3.1 UD60x18 格式

利率参数使用 **UD60x18 定点数格式**（60 位小数精度）：

```
实际数值 = 存储值 / 10^18
```

例如，1 天档的利率参数：
```
存储值: 1003000000000000000
实际值: 1003000000000000000 / 10^18 = 1.003
日利率: 0.3%
```

### 3.2 各档位利率详解

当前合约配置（`Staking.sol`）：

#### 1天档 - 低风险短期
```
日利率: 0.3%
UD60x18: 1003000000000000000
质押 1 天总收益: 1.003^1 - 1 = 0.3%
```

#### 30天档 - 中期投资
```
日利率: 0.6%
UD60x18: 1006000000000000000
质押 30 天总收益: 1.006^30 - 1 ≈ 19.88%

计算示例:
1000 USDT 质押 30 天
最终金额 = 1000 × 1.006^30 ≈ 1198.8 USDT
盈利 = 198.8 USDT
```

#### 90天档 - 高收益长期
```
日利率: 0.9%
UD60x18: 1009000000000000000
质押 90 天总收益: 1.009^90 - 1 ≈ 123.44%

计算示例:
1000 USDT 质押 90 天
最终金额 = 1000 × 1.009^90 ≈ 2234.4 USDT
盈利 = 1234.4 USDT
```

#### 180天档 - 超高收益
```
日利率: 1.5%
UD60x18: 1015000000000000000
质押 180 天总收益: 1.015^180 - 1 ≈ 1536.14%

计算示例:
1000 USDT 质押 180 天
最终金额 = 1000 × 1.015^180 ≈ 16361.4 USDT
盈利 = 15361.4 USDT

⚠️ 警告: 这个收益率接近 16倍，需要极其充足的代币储备！
```

### 3.3 如何反向计算日利率

如果你想设定特定的总收益率，可以用以下公式反推日利率：

```
已知: 总收益率 R, 质押天数 n
求: 每日利率 r

公式: (1 + r)^n = 1 + R
解: r = (1 + R)^(1/n) - 1

示例: 希望 30 天总收益 10%
r = 1.10^(1/30) - 1 ≈ 0.003177 (0.3177%)
UD60x18 = 1.003177 × 10^18 = 1003177000000000000
```

---

## 四、不定天数的收益计算

### 4.1 问题场景

虽然合约定义了 4 个标准档位（1/30/90/180 天），但用户可能在**任意天数**查询收益，例如：
- 质押了 30 天档，但只过了 15 天就查询收益
- 质押了 90 天档，但过了 100 天才解除质押（封顶到 90 天）

### 4.2 计算方式

系统采用**按实际天数的复利计算**：

```
实际收益 = 本金 × (日利率)^实际天数
```

**关键代码逻辑**：
```solidity
// 计算实际天数（不超过质押期限）
stakingDuration = _min40(stakingDuration, getStakePeriod(stakeIndex));
uint256 compoundPeriods = stakingDuration / 1 days;

// 应用复利公式
compoundedAmount = principalAmount × (rate)^compoundPeriods
```

### 4.3 示例计算

#### 场景 1：30天档，质押 15 天后查询

```
本金: 1000 USDT
日利率: 1.006 (0.6%)
实际天数: 15 天

收益计算:
最终金额 = 1000 × 1.006^15
         ≈ 1000 × 1.0938
         = 1093.8 USDT

盈利部分: 93.8 USDT
```

#### 场景 2：1天档，质押 0.5 天后查询

```
本金: 1000 USDT
实际天数: 0.5 天

⚠️ 注意: 代码中 compoundPeriods = stakingDuration / 1 days
         如果不满 1 天，compoundPeriods = 0

收益计算:
最终金额 = 1000 × 1.003^0 = 1000 USDT

结论: 不满 1 天时，收益为 0（按天计算，不支持小时级别）
```

---

## 五、收益计算可视化

### 5.1 复利增长曲线

```
收益金额
  ↑
  │              ╱────────── 30天档 (日利率高)
  │            ╱
  │          ╱
  │        ╱        ╱─────── 1天档 (日利率低)
  │      ╱        ╱
  │    ╱        ╱
  │  ╱        ╱
  │╱________╱________________→ 时间（天）
  0  5  10  15  20  25  30
```

**关键特征**：
- 曲线向上弯曲（指数增长）
- 不是直线（说明是复利而非单利）
- 期限越长的档位，日利率越高，曲线越陡

### 5.2 复利 vs 单利对比

以 30 天档为例（0.6% 日利率，总收益 19.88%）：

| 天数 | 复利收益 | 单利收益 | 差额 |
|------|---------|---------|------|
| 0 天 | 0% | 0% | 0 |
| 10 天 | 6.17% | 6.00% | +0.17% |
| 20 天 | 12.72% | 12.00% | +0.72% |
| 30 天 | 19.88% | 18.00% | +1.88% |

```
收益率
  ↑
20%│                    ●────── 复利（上凸，加速增长）
  │                  ╱
  │                ╱
  │              ╱    ──────── 单利（直线）
  │            ╱    ╱
  │          ╱    ╱
  │        ╱    ╱
  │      ╱    ╱
  0│____╱____╱_________________→ 天数
      0   10   20   30
```

**关键发现**:
- ✅ **复利优势明显**: 30天多赚 1.88%
- ✅ **曲线上凸**: 后期增长加速（利滚利效应）
- ✅ **长期收益更高**: 时间越长，复利优势越明显

对于 180天档（1.5% 日利率）：
```
复利收益: 1536.14%
单利收益: 270.00%
差额: 1266.14%（复利多赚 5.7倍！）
```

---

## 六、提现时的收益分配

### 6.1 收益处理流程

当用户调用 `unstake()` 解除质押时，系统会进行以下操作（`StakingBase.sol:200-264`）：

```
1. 计算总收益（SYI 计价）
   ↓
2. 将 SYI 兑换为 USDT
   ↓
3. 计算盈利部分 = USDT - 本金
   ↓
4. 扣除各项费用（从盈利部分扣除）：
   - 好友奖励: 5%
   - 团队奖励: 0-35%（根据推荐人层级）
   - 赎回费: 1%
   ↓
5. 剩余金额转给用户
```

### 6.2 示例计算

```
假设:
- 本金: 1000 USDT
- 质押 30 天
- 收益: 100 USDT（10% 总收益）
- 兑换后: 1100 USDT

盈利部分: 100 USDT

费用扣除:
- 好友奖励: 100 × 5% = 5 USDT
- 团队奖励: 100 × 20% = 20 USDT（假设推荐人是 V4 级别）
- 小计: 25 USDT

用户实得: 1100 - 25 = 1075 USDT

赎回费: 1075 × 1% = 10.75 USDT
最终到账: 1064.25 USDT
```

---

## 七、当前实现的限制

### 7.1 无法提前支取盈利

当前合约设计中，用户**必须等到质押期满才能解除质押**。主要限制：

1. **时间锁定**:
   ```solidity
   if (block.timestamp - stakeTime < getStakePeriod(stakeIndex)) {
       revert StakingPeriodNotMet();
   }
   ```

2. **全额提取**: 解除质押时，本金和收益一起提取，无法只提利息。

3. **一次性结算**: 没有"部分提取"机制。

---

## 八、提前支取盈利功能设计方案

### 8.1 需求分析

**目标**: 允许用户在质押期间提前支取**已产生的盈利部分**，但**本金保持质押状态**。

**业务场景**:
- 用户质押了 180 天档，但在第 60 天需要部分资金周转
- 用户希望提取已产生的利息，但保持质押继续享受后续收益

### 8.2 方案一：简单盈利提取（推荐）

#### 核心逻辑

```solidity
function withdrawInterest(uint256 stakeIndex) external returns (uint256) {
    Record storage stakeRecord = userStakeRecord[msg.sender][stakeIndex];

    // 1. 检查质押是否有效
    require(!stakeRecord.status, "Already withdrawn");

    // 2. 计算当前总价值
    uint256 currentValue = _calculateStakeReward(stakeRecord);

    // 3. 计算可提取的盈利
    uint256 profit = currentValue - stakeRecord.amount;
    require(profit > 0, "No profit to withdraw");

    // 4. 将盈利兑换为 USDT
    (uint256 usdtReceived, uint256 syiUsed) = _swapSYIForReward(profit);

    // 5. 扣除费用（好友奖励 5% + 团队奖励 + 赎回费 1%）
    uint256 fees = _distributeRewardsAndFees(msg.sender, usdtReceived);

    // 6. 转账给用户
    uint256 userPayout = usdtReceived - fees;
    IERC20(USDT).transfer(msg.sender, userPayout);

    // 7. 重置质押起始时间（重要！）
    stakeRecord.stakeTime = uint40(block.timestamp);

    return userPayout;
}
```

#### 关键设计点

1. **重置质押起始时间**: 提取利息后，将 `stakeTime` 重置为当前时间，这样：
   - 用户不能反复提取同一笔利息
   - 后续收益从新的基数（本金）开始计算

2. **sSYI 余额不变**:
   - 用户的 `balances[user]` 保持不变（仍然是本金数额）
   - `totalSupply` 不减少

3. **质押期限不变**:
   - 原质押期限到期时间不变
   - 例如原本 180 天到期，提取利息后仍然是 180 天到期

#### 优点
- ✅ 实现简单，改动最小
- ✅ 不影响现有质押逻辑
- ✅ 用户体验直观

#### 缺点
- ⚠️ 每次提取利息后，后续收益会降低（因为失去了复利效应）
- ⚠️ 可能被频繁调用，消耗 gas 和流动性

### 8.3 方案二：部分复利保留

#### 核心逻辑

允许用户提取部分利息，但强制保留一定比例用于继续复利：

```solidity
uint256 constant WITHDRAW_RATE = 50; // 只能提取 50% 的利息

function withdrawInterest(uint256 stakeIndex) external returns (uint256) {
    // ... 前面步骤相同 ...

    // 计算可提取金额
    uint256 withdrawableProfit = profit * WITHDRAW_RATE / 100;
    uint256 retainedProfit = profit - withdrawableProfit;

    // 更新本金（加上保留的利息）
    stakeRecord.amount += retainedProfit;
    balances[msg.sender] += retainedProfit;

    // 仅兑换可提取部分
    (uint256 usdtReceived, ) = _swapSYIForReward(withdrawableProfit);

    // ... 后续转账 ...
}
```

#### 优点
- ✅ 保留部分复利效应
- ✅ 激励用户长期持有

#### 缺点
- ⚠️ 逻辑复杂度增加
- ⚠️ 用户可能不理解"为什么不能全部提取"

### 8.4 方案三：时间间隔限制

#### 核心逻辑

限制提取频率，例如每 30 天只能提取一次：

```solidity
mapping(address => mapping(uint256 => uint40)) lastWithdrawTime;
uint256 constant WITHDRAW_COOLDOWN = 30 days;

function withdrawInterest(uint256 stakeIndex) external returns (uint256) {
    require(
        block.timestamp - lastWithdrawTime[msg.sender][stakeIndex] >= WITHDRAW_COOLDOWN,
        "Cooldown period not met"
    );

    // ... 提取逻辑 ...

    lastWithdrawTime[msg.sender][stakeIndex] = uint40(block.timestamp);
}
```

#### 优点
- ✅ 减少频繁调用
- ✅ 保护流动性池

#### 缺点
- ⚠️ 降低资金灵活性

### 8.5 方案四：累计利息提取（最灵活）

#### 核心逻辑

不重置质押时间，而是记录"已提取的利息总额"：

```solidity
struct Record {
    uint40 stakeTime;
    uint160 amount;           // 本金
    uint160 withdrawnProfit;  // 已提取的利息
    bool status;
    uint8 stakeIndex;
}

function withdrawInterest(uint256 stakeIndex) external returns (uint256) {
    Record storage stakeRecord = userStakeRecord[msg.sender][stakeIndex];

    // 1. 计算当前总价值
    uint256 currentValue = _calculateStakeReward(stakeRecord);

    // 2. 计算累计盈利
    uint256 totalProfit = currentValue - stakeRecord.amount;

    // 3. 计算可提取盈利（减去已提取部分）
    uint256 withdrawableProfit = totalProfit - stakeRecord.withdrawnProfit;
    require(withdrawableProfit > 0, "No new profit");

    // 4. 兑换并转账
    (uint256 usdtReceived, ) = _swapSYIForReward(withdrawableProfit);
    // ... 扣费、转账 ...

    // 5. 记录已提取金额
    stakeRecord.withdrawnProfit += withdrawableProfit;
}
```

#### 优点
- ✅ 不影响复利计算（质押时间不重置）
- ✅ 灵活性最高
- ✅ 准确追踪提取历史

#### 缺点
- ⚠️ 需要修改 `Record` 结构体（⚠️ 存储槽变化，升级风险）
- ⚠️ 逻辑较复杂

---

## 九、实现难度评估

### 9.1 技术难度

| 方案 | 合约改动 | Gas 成本 | 测试复杂度 | 升级风险 | 推荐度 |
|------|---------|---------|-----------|---------|--------|
| 方案一：简单提取 | ⭐⭐ | ⭐⭐ | ⭐⭐ | 低 | ⭐⭐⭐⭐⭐ |
| 方案二：部分保留 | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 中 | ⭐⭐⭐ |
| 方案三：时间限制 | ⭐⭐ | ⭐⭐ | ⭐⭐ | 低 | ⭐⭐⭐⭐ |
| 方案四：累计提取 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 高 | ⭐⭐⭐⭐⭐ |

### 9.2 主要挑战

#### 1. 存储结构变化
如果采用方案四，需要修改 `Record` 结构体：
```solidity
// 旧结构
struct Record {
    uint40 stakeTime;
    uint160 amount;
    bool status;
    uint8 stakeIndex;
}

// 新结构（⚠️ 需要合约升级）
struct Record {
    uint40 stakeTime;
    uint160 amount;
    uint160 withdrawnProfit;  // 新增字段
    bool status;
    uint8 stakeIndex;
}
```

**问题**: 已部署的合约无法直接修改，需要：
- 部署新版本合约
- 迁移用户数据
- 或使用代理模式升级

#### 2. 流动性池压力
频繁提取利息会：
- 持续卖出 SYI → 下行压力
- 消耗 USDT 流动性

**解决方案**:
- 设置提取冷却期（30 天）
- 设置单次最大提取比例（50%）
- 收取较高的提前提取费（2-5%）

#### 3. 复利效应损失
提取利息后，用户失去复利增长的机会。

**用户教育**:
需要在前端明确提示：
```
⚠️ 提前提取利息将影响后续收益
原预期收益: 100 USDT
提前提取后: 85 USDT（损失 15%）
```

### 9.3 推荐方案

#### 最佳方案：方案一 + 方案三组合

```solidity
function withdrawInterest(uint256 stakeIndex) external onlyEOA returns (uint256) {
    address user = msg.sender;
    Record storage stakeRecord = userStakeRecord[user][stakeIndex];

    // 0. 检查冷却期（30 天一次）
    require(
        block.timestamp - lastWithdrawTime[user][stakeIndex] >= 30 days,
        "Cooldown: 30 days between withdrawals"
    );

    // 1. 检查质押状态
    require(!stakeRecord.status, "Already withdrawn");

    // 2. 计算盈利
    uint256 currentValue = _calculateStakeReward(stakeRecord);
    uint256 profit = currentValue - stakeRecord.amount;
    require(profit > 0, "No profit available");

    // 3. 限制单次提取（最多 80%）
    uint256 maxWithdraw = profit * 80 / 100;

    // 4. 兑换为 USDT
    (uint256 usdtReceived, uint256 syiUsed) = _swapSYIForReward(maxWithdraw);

    // 5. 扣除费用（5% 好友 + 团队 + 2% 提前提取费）
    uint256 fees = _distributeInterestWithdrawFees(user, usdtReceived);

    // 6. 转账
    uint256 userPayout = usdtReceived - fees;
    IERC20(USDT).transfer(user, userPayout);

    // 7. 重置起始时间
    stakeRecord.stakeTime = uint40(block.timestamp);
    lastWithdrawTime[user][stakeIndex] = uint40(block.timestamp);

    emit InterestWithdrawn(user, stakeIndex, profit, userPayout);

    return userPayout;
}
```

#### 实现步骤

1. **添加状态变量** (5 行代码):
   ```solidity
   mapping(address => mapping(uint256 => uint40)) public lastInterestWithdrawTime;
   uint256 public constant INTEREST_WITHDRAW_COOLDOWN = 30 days;
   uint256 public constant MAX_INTEREST_WITHDRAW_RATE = 80; // 80%
   event InterestWithdrawn(address indexed user, uint256 stakeIndex, uint256 profit, uint256 payout);
   ```

2. **添加新函数** (~80 行代码):
   - `withdrawInterest(uint256 stakeIndex)`: 主函数
   - `_distributeInterestWithdrawFees(address, uint256)`: 费用分配
   - `canWithdrawInterest(address, uint256)`: 查询函数

3. **测试用例** (~200 行):
   - 正常提取流程
   - 冷却期限制
   - 零收益处理
   - 费用计算验证
   - 多次提取测试

#### 预计工作量
- **开发时间**: 2-3 天
- **测试时间**: 2-3 天
- **审计建议**: 需要，涉及资金操作
- **Gas 估算**: ~150,000 - 200,000 gas/次

---

## 十、总结

### 10.1 当前收益机制特点

| 特性 | 说明 |
|------|------|
| 计算方式 | 每日复利（指数增长） |
| 精度 | 60 位定点数（UD60x18） |
| 实时性 | 实时查询，无需等待结算 |
| 灵活性 | 支持不定天数查询 |
| 限制 | 必须到期才能提取 |

### 10.2 提前支取功能建议

**推荐方案**: 简单盈利提取 + 30 天冷却期 + 80% 提取上限

**核心理由**:
1. ✅ 实现难度低，风险可控
2. ✅ 满足用户资金灵活性需求
3. ✅ 保护流动性池和代币价格
4. ✅ 通过冷却期和上限防止滥用

**注意事项**:
- 需要向用户明确说明复利损失
- 建议设置较高的提前提取费（2-5%）
- 需要充分测试边界情况
- 建议进行专业审计

---

## 附录：关键代码位置

| 功能 | 文件 | 行号 |
|------|------|------|
| 收益计算 | `StakingBase.sol` | 1167-1196 |
| 质押函数 | `StakingBase.sol` | 193-198 |
| 解除质押 | `StakingBase.sol` | 200-264 |
| 利率配置 | `Staking.sol` | 27-41 |
| 费用分配 | `StakingBase.sol` | 999-1078 |

---

**文档版本**: v1.0
**最后更新**: 2025-10-13
**作者**: SYI 开发团队
