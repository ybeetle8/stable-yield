# 质押系统黑白名单机制详解

## 概述

SYI 生态系统中存在两套独立的黑白名单机制：
1. **SYI 代币合约的黑白名单** - 控制交易权限和费用豁免
2. **质押合约的节点等级系统** - 作为团队奖励分配的"白名单"保障机制

---

## 一、SYI 代币合约的黑白名单

代码位置：`contracts/SYI/abstract/SYIBase.sol`

### 1.1 白名单机制（Fee Whitelist）

#### 数据结构
```solidity
mapping(address => bool) public feeWhitelisted;
```

#### 功能说明
白名单地址享有以下特权：
1. **免除所有交易费用** - 买入和卖出时不收取任何费用
2. **绕过延迟购买检查** - 不受 `delayedBuyEnabled` 限制
3. **直接执行转账** - 在 `_update()` 函数中优先处理，跳过复杂的买卖逻辑

#### 默认白名单地址
在 `initializeWhitelist()` 中自动添加：
- 合约 owner（部署者）
- SYI 代币合约本身
- Staking 质押合约
- Uniswap Router 合约

#### 管理函数

**单个地址设置**
```solidity
function setFeeWhitelisted(address account, bool whitelisted) external onlyOwner
```

**批量设置**
```solidity
function setBatchFeeWhitelisted(address[] memory accounts, bool _whitelisted) external onlyOwner
```

#### 工作流程

```
交易发起
    ↓
_update(from, to, value)
    ↓
检查：from 或 to 是否在白名单？
    ↓
   是 → 直接执行 super._update()，无费用
    ↓
   否 → 继续判断是买入/卖出/普通转账
```

**代码位置：** SYIBase.sol:512-519
```solidity
// Check whitelist status early
bool isWhitelisted = feeWhitelisted[from] || feeWhitelisted[to];

// Direct transfers not involving pair
if (isWhitelisted) {
    super._update(from, to, value);
    return;
}
```

---

### 1.2 黑名单机制（Blacklist）

#### 数据结构
```solidity
mapping(address => bool) public blacklisted;
```

#### 功能说明
黑名单地址的限制：
1. **禁止买入 SYI** - 在 `_handleBuy()` 中被 `notBlacklisted(to)` modifier 拦截
2. **禁止卖出 SYI** - 在 `_handleSell()` 中被 `notBlacklisted(from)` modifier 拦截
3. **抛出 Blacklisted 错误** - 交易立即回滚

#### Modifier 实现
```solidity
modifier notBlacklisted(address account) {
    if (blacklisted[account]) revert Blacklisted();
    _;
}
```

#### 管理函数

**单个地址设置**
```solidity
function setBlacklisted(address account, bool _blacklisted) external onlyOwner
```

**批量设置**
```solidity
function setBatchBlacklisted(address[] memory accounts, bool _blacklisted) external onlyOwner
```

#### 工作流程

```
用户尝试买入/卖出
    ↓
进入 _handleBuy() 或 _handleSell()
    ↓
notBlacklisted(address) modifier 检查
    ↓
   是黑名单 → revert Blacklisted()
    ↓
   否 → 继续执行交易逻辑
```

**代码位置：** SYIBase.sol:563-584 (买入)
```solidity
function _handleBuy(
    address from,
    address to,
    uint256 amount
) private notBlacklisted(to) delayedBuyCheck(to) {
    // 买入逻辑
}
```

**代码位置：** SYIBase.sol:586-600 (卖出)
```solidity
function _handleSell(
    address from,
    address to,
    uint256 amount
) private notBlacklisted(from) {
    // 卖出逻辑
}
```

---

## 二、质押合约的节点等级系统（Node Tier System）

代码位置：`contracts/SYI-Staking/abstract/StakingBase.sol:137-1932`

### 2.1 系统概述

节点等级系统是一种**白名单保障机制**，允许管理员为特定用户设置最低团队奖励等级（V1 或 V2），确保他们即使 teamKPI 不足也能享受对应的团队奖励资格。

### 2.2 数据结构

#### 节点等级记录
```solidity
struct NodeTierRecord {
    uint8 tier;           // 等级 (1=V1, 2=V2)
    uint40 setTime;       // 设置时间戳
    address setBy;        // 设置操作者地址
    bool active;          // 是否激活
}

mapping(address => NodeTierRecord) public nodeTiers;
```

#### 管理员地址
```solidity
address public tierManager;  // 只有此地址可以设置节点等级
```

### 2.3 核心概念

#### 三种等级类型

1. **自然等级（Natural Tier）** - 基于 teamKPI 自动计算
   - 范围：0-7 (对应 V0-V7)
   - 计算函数：`_calculateNaturalTier()`
   - 依据：团队总投资额（teamTotalInvestValue）

2. **节点等级（Node Tier）** - 管理员手动设置
   - 范围：1-2 (对应 V1-V2)
   - 作用：最低保障
   - 限制：只能设置 V1 或 V2

3. **最终等级（Final Tier）** - 实际生效的等级
   - 计算公式：`MAX(自然等级, 节点等级)`
   - 用于团队奖励分配

#### 等级阈值配置（Mainnet）

| 等级 | 所需 teamKPI (USDT) | 团队奖励比例 |
|------|---------------------|--------------|
| V1   | 10,000 USDT         | 5%           |
| V2   | 50,000 USDT         | 10%          |
| V3   | 200,000 USDT        | 15%          |
| V4   | 500,000 USDT        | 20%          |
| V5   | 1,000,000 USDT      | 25%          |
| V6   | 2,500,000 USDT      | 30%          |
| V7   | 5,000,000 USDT      | 35%          |

### 2.4 等级计算逻辑

#### 最终等级计算（_getUserTier）

**代码位置：** StakingBase.sol:1541-1561

```solidity
function _getUserTier(address user) private view returns (uint8 tier) {
    // 1. rootAddress 永远返回 0
    if (user == rootAddress) {
        return 0;
    }

    // 2. 非 Preacher 用户返回 0（节点等级也无效）
    if (!isPreacher(user)) {
        return 0;
    }

    // 3. 计算自然等级（基于 teamKPI）
    uint8 naturalTier = _calculateNaturalTier(user);

    // 4. 检查节点等级
    NodeTierRecord memory record = nodeTiers[user];
    uint8 nodeTier = record.active ? record.tier : 0;

    // 5. 取最大值
    return _max8(naturalTier, nodeTier);
}
```

#### 关键前置条件

1. **必须是 Preacher**
   - 定义：`currentStakeValue(user) >= 200 ether`
   - 如果不是 Preacher，所有等级（包括节点等级）都无效

2. **rootAddress 永远是 V0**
   - 根地址不参与等级计算

#### 自然等级计算（_calculateNaturalTier）

**代码位置：** StakingBase.sol:1569-1588

```solidity
function _calculateNaturalTier(address user) private view returns (uint8 tier) {
    // rootAddress 或非 Preacher 返回 0
    if (user == rootAddress || !isPreacher(user)) {
        return 0;
    }

    uint256 teamKPI = getTeamKpi(user);
    IStaking.TeamTier[7] memory tiers = _getTeamTiers();

    // 从高到低遍历等级阈值
    for (uint256 i = 0; i < tiers.length; ) {
        if (teamKPI >= tiers[i].threshold) {
            return uint8(7 - i);  // 返回对应等级
        }
        unchecked {
            ++i;
        }
    }

    return 0;  // 未达到任何阈值
}
```

**遍历顺序**
```
tiers[0] → V7 (5,000,000)
tiers[1] → V6 (2,500,000)
tiers[2] → V5 (1,000,000)
tiers[3] → V4 (500,000)
tiers[4] → V3 (200,000)
tiers[5] → V2 (50,000)
tiers[6] → V1 (10,000)
```

### 2.5 管理函数

#### 设置 tierManager
```solidity
function setTierManager(address _tierManager) external onlyOwner
```
- 只能由合约 owner 调用
- 传入 `address(0)` 可以禁用节点等级功能

#### 单个设置节点等级
```solidity
function setNodeTier(address user, uint8 tier) external onlyTierManager
```
- 只能由 tierManager 调用
- `tier` 必须是 1 或 2（V1 或 V2）
- 不能为 rootAddress 设置

**代码位置：** StakingBase.sol:1772-1788

#### 移除节点等级
```solidity
function removeNodeTier(address user) external onlyTierManager
```
- 将 `active` 设为 `false`
- 保留历史记录（setTime, setBy 等）

**代码位置：** StakingBase.sol:1795-1802

#### 批量设置节点等级
```solidity
function batchSetNodeTier(address[] calldata users, uint8[] calldata tiers) external onlyTierManager
```
- 最多一次处理 100 个用户
- 数组长度必须一致

**代码位置：** StakingBase.sol:1811-1842

#### 批量移除节点等级
```solidity
function batchRemoveNodeTier(address[] calldata users) external onlyTierManager
```
- 最多一次处理 100 个用户

**代码位置：** StakingBase.sol:1849-1867

### 2.6 查询函数

#### 查询节点等级详情
```solidity
function getNodeTierDetails(address user) external view returns (
    bool hasNodeTier,    // 是否设置了节点等级
    uint8 tier,          // 节点等级 (0=未设置)
    uint40 setTime,      // 设置时间
    address setBy,       // 设置者地址
    bool isActive        // 是否激活
)
```

**代码位置：** StakingBase.sol:1882-1897

#### 查询完整等级信息
```solidity
function getUserTierBreakdown(address user) external view returns (
    bool isPreacherStatus,   // 是否为 Preacher
    uint8 naturalTier,       // 自然等级 (基于 teamKPI)
    uint8 nodeTier,          // 节点等级 (管理员设置)
    uint8 finalTier,         // 最终等级 (实际生效)
    bool usingNodeTier       // 是否使用了节点等级
)
```

**代码位置：** StakingBase.sol:1908-1931

**判断逻辑**
```solidity
usingNodeTier = (nodeTier > 0 && finalTier == nodeTier && naturalTier < nodeTier)
```

### 2.7 应用场景

#### 场景 1：节点等级作为保底

```
用户 A:
  - 当前质押: 250 USDT (满足 Preacher 200 门槛)
  - teamKPI: 8,000 USDT (不足 V1 的 10,000)
  - 自然等级: V0
  - 节点等级: 管理员设置 V1
  - 最终等级: V1 (MAX(0, 1) = 1)
  - 结果: 享受 5% 团队奖励
```

#### 场景 2：自然等级更高

```
用户 B:
  - 当前质押: 300 USDT (满足 Preacher)
  - teamKPI: 60,000 USDT (达到 V2 的 50,000)
  - 自然等级: V2
  - 节点等级: 管理员设置 V1
  - 最终等级: V2 (MAX(2, 1) = 2)
  - 结果: 享受 10% 团队奖励（自然升级不受限）
```

#### 场景 3：不是 Preacher

```
用户 C:
  - 当前质押: 150 USDT (不足 Preacher 200 门槛)
  - teamKPI: 100,000 USDT
  - 自然等级: V0 (因为不是 Preacher)
  - 节点等级: 管理员设置 V2
  - 最终等级: V0 (不是 Preacher，所有等级无效)
  - 结果: 无法享受团队奖励
```

### 2.8 团队奖励分配中的应用

**代码位置：** StakingBase.sol:1382-1442

在 `_distributeHybridRewards()` 函数中：

```solidity
for (uint256 i = 0; i < referralChain.length; ) {
    uint8 currentTier = memberTiers[i];  // 这里使用的是 _getUserTier() 的结果

    if (
        currentTier > 0 &&
        !tierAllocated[currentTier] &&
        isPreacher(referralChain[i])  // 必须是 Preacher
    ) {
        uint256 tierRewardRate = _getTierRewardRate(currentTier);
        uint256 actualRewardRate = tierRewardRate - cumulativeAllocatedRate;

        if (actualRewardRate > 0) {
            uint256 memberReward = (_interset * actualRewardRate) / PERCENTAGE_BASE;
            IERC20(USDT).transfer(referralChain[i], memberReward);
            // ...
        }

        tierAllocated[currentTier] = true;
        cumulativeAllocatedRate = tierRewardRate;
    }
    // ...
}
```

**关键点**
1. 使用最终等级（自然 vs 节点的较大值）
2. 必须满足 Preacher 资格
3. 采用"差额奖励"模式，避免重复分配

---

## 三、黑白名单交互流程图

### 3.1 SYI 代币交易流程

```
用户发起转账/交易
    ↓
_update(from, to, value)
    ↓
是 mint/burn (零地址)？
    ↓
   是 → 直接执行 super._update()
    ↓
   否 → from 或 to 在白名单？
    ↓
       是 → 直接执行 super._update()（无费用）
    ↓
       否 → 判断交易类型
    ↓
       ├─ 买入 → _handleBuy()
       │           ↓
       │      检查黑名单 (notBlacklisted)
       │           ↓
       │          是 → revert Blacklisted()
       │           ↓
       │          否 → 检查延迟购买
       │           ↓
       │          否 → 执行买入（无费用）
       │
       ├─ 卖出 → _handleSell()
       │           ↓
       │      检查黑名单 (notBlacklisted)
       │           ↓
       │          是 → revert Blacklisted()
       │           ↓
       │          否 → 检查冷却时间
       │           ↓
       │      满足 → 执行卖出（无费用）
       │
       └─ 普通转账 → super._update()
```

### 3.2 质押合约等级计算流程

```
用户质押并产生收益
    ↓
unstake() 或 withdrawInterest()
    ↓
_distributeTeamReward(referralChain, interest)
    ↓
遍历推荐链中的每个地址
    ↓
调用 _getUserTier(address)
    ↓
    ├─ 是 rootAddress？
    │       ↓
    │      是 → 返回 0
    │
    ├─ 是 Preacher (质押 >= 200)?
    │       ↓
    │      否 → 返回 0
    │       ↓
    │      是 → 计算自然等级
    │           ↓
    │      _calculateNaturalTier()
    │           ↓
    │      根据 teamKPI 匹配阈值
    │           ↓
    │      得到自然等级 (0-7)
    │
    └─ 检查节点等级
            ↓
       nodeTiers[user].active == true?
            ↓
           是 → nodeTier = record.tier (1 或 2)
            ↓
           否 → nodeTier = 0
            ↓
       最终等级 = MAX(naturalTier, nodeTier)
            ↓
       用于计算团队奖励分配
```

---

## 四、安全性与权限控制

### 4.1 权限矩阵

| 功能 | 权限要求 | 合约 |
|------|----------|------|
| 设置费用白名单 | onlyOwner | SYI |
| 设置黑名单 | onlyOwner | SYI |
| 设置 tierManager | onlyOwner | Staking |
| 设置节点等级 | onlyTierManager | Staking |
| 移除节点等级 | onlyTierManager | Staking |
| 批量操作节点等级 | onlyTierManager | Staking |

### 4.2 安全限制

#### SYI 代币合约
1. 白名单/黑名单只能由 owner 修改
2. 初始白名单只能设置一次（`_whitelistInitialized`）
3. 黑名单检查在买卖逻辑中强制执行

#### 质押合约
1. 节点等级只能是 V1 或 V2（限制：`tier >= 1 && tier <= 2`）
2. 不能为 rootAddress 设置节点等级
3. 批量操作最多 100 个地址
4. 节点等级必须配合 Preacher 资格才生效
5. tierManager 可以被设为 `address(0)` 以禁用功能

---

## 五、事件日志

### 5.1 SYI 代币事件

```solidity
// 白名单/黑名单事件（在接口中定义，但 SYIBase 未使用标准事件名）
// 实际未发出这些事件，只有状态变更
```

### 5.2 质押合约事件

```solidity
event TierManagerUpdated(
    address indexed oldManager,
    address indexed newManager,
    address indexed operator,
    uint256 timestamp
);

event NodeTierSet(
    address indexed user,
    uint8 tier,
    address indexed setBy,
    uint256 timestamp
);

event NodeTierRemoved(
    address indexed user,
    uint8 previousTier,
    address indexed removedBy,
    uint256 timestamp
);

event NodeTierBatchSet(
    address[] users,
    uint8[] tiers,
    address indexed setBy,
    uint256 count,
    uint256 timestamp
);

event NodeTierUsed(
    address indexed user,
    uint8 naturalTier,
    uint8 nodeTier,
    uint8 finalTier,
    string reason
);
```

---

## 六、使用建议

### 6.1 SYI 代币黑白名单

**白名单使用场景**
- 核心合约地址（自动添加）
- 合作伙伴地址（需要免费转账）
- 团队多签钱包

**黑名单使用场景**
- 恶意机器人地址
- 违规交易账户
- 临时冻结可疑地址

⚠️ **注意**：根据 CLAUDE.md 所述，上交易所时应移除黑名单功能，否则可能被标记为诈骗项目。

### 6.2 质押合约节点等级

**设置节点等级的场景**
- 早期贡献者激励（保底 V1 或 V2）
- 战略合作伙伴奖励
- 社区领袖扶持

**移除节点等级的场景**
- 用户已自然达到更高等级
- 合作关系终止
- 发现滥用行为

**最佳实践**
1. 优先让用户通过 teamKPI 自然升级
2. 节点等级仅作为临时扶持手段
3. 定期审查节点等级列表
4. 记录设置原因（链下文档）

---

## 七、代码示例

### 7.1 查询用户黑白名单状态

```javascript
// 使用 ethers.js
const syiContract = await ethers.getContractAt("SYI", syiAddress);

// 查询白名单
const isWhitelisted = await syiContract.feeWhitelisted(userAddress);
console.log("在白名单:", isWhitelisted);

// 查询黑名单
const isBlacklisted = await syiContract.blacklisted(userAddress);
console.log("在黑名单:", isBlacklisted);
```

### 7.2 查询用户完整等级信息

```javascript
// 使用 ethers.js
const stakingContract = await ethers.getContractAt("Staking", stakingAddress);

const tierInfo = await stakingContract.getUserTierBreakdown(userAddress);

console.log({
    isPreacher: tierInfo.isPreacherStatus,
    naturalTier: tierInfo.naturalTier,      // 基于 teamKPI
    nodeTier: tierInfo.nodeTier,            // 管理员设置
    finalTier: tierInfo.finalTier,          // 实际生效
    usingNodeTier: tierInfo.usingNodeTier   // 是否靠节点等级提升
});
```

### 7.3 批量设置节点等级

```javascript
const stakingContract = await ethers.getContractAt("Staking", stakingAddress);

const users = [
    "0x1234...",
    "0x5678...",
    "0x9abc..."
];

const tiers = [1, 2, 1];  // V1, V2, V1

await stakingContract.batchSetNodeTier(users, tiers);
console.log("批量设置完成");
```

---

## 八、FAQ

### Q1: 白名单地址可以买卖 SYI 吗？
**A:** 可以，白名单只是免除交易费用，不影响交易权限。

### Q2: 黑名单地址的代币会被没收吗？
**A:** 不会，黑名单只禁止交易，不影响持币。

### Q3: 节点等级会限制自然升级吗？
**A:** 不会，最终等级是 MAX(自然, 节点)，自然等级可以超越节点等级。

### Q4: 如果不是 Preacher，设置 V2 节点等级有用吗？
**A:** 无用，不满足 Preacher 资格时，所有等级（包括节点等级）都无效。

### Q5: tierManager 可以是多签钱包吗？
**A:** 可以，推荐使用多签钱包提高安全性。

### Q6: 节点等级可以设置 V3-V7 吗？
**A:** 不可以，代码限制只能设置 V1 (tier=1) 或 V2 (tier=2)。

### Q7: 移除节点等级后，历史记录会删除吗？
**A:** 不会删除，只是将 `active` 设为 false，保留 setTime、setBy 等信息。

---

## 九、总结

| 机制 | 合约 | 作用范围 | 权限控制 | 用途 |
|------|------|----------|----------|------|
| 费用白名单 | SYI | 交易费用豁免 | onlyOwner | 核心地址免费转账 |
| 黑名单 | SYI | 禁止交易 | onlyOwner | 风险地址隔离 |
| 节点等级 | Staking | 团队奖励保底 | onlyTierManager | 用户扶持与激励 |

**关键设计理念**
1. SYI 的黑白名单 = 交易权限控制
2. 质押的节点等级 = 奖励资格保障
3. 节点等级不限制自然升级 = MAX 逻辑
4. 必须满足 Preacher 资格 = 质押 >= 200 USDT

**风险提示**
- 黑名单功能应谨慎使用，避免中心化争议
- 节点等级应作为临时扶持，而非长期依赖
- 定期审计白名单地址，防止权限滥用
