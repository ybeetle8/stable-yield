# èŠ‚ç‚¹ç­‰çº§ç®¡ç†ç³»ç»Ÿå®ç°æ–¹æ¡ˆï¼ˆæ–¹æ¡ˆAæ”¹è¿›ç‰ˆï¼‰

## ç›®å½•
- [éœ€æ±‚æ¦‚è¿°](#éœ€æ±‚æ¦‚è¿°)
- [è®¾è®¡æ–¹æ¡ˆ](#è®¾è®¡æ–¹æ¡ˆ)
- [æ ¸å¿ƒé€»è¾‘](#æ ¸å¿ƒé€»è¾‘)
- [å®Œæ•´å®ç°ä»£ç ](#å®Œæ•´å®ç°ä»£ç )
- [å½±å“åˆ†æ](#å½±å“åˆ†æ)
- [å®‰å…¨é£é™©è¯„ä¼°](#å®‰å…¨é£é™©è¯„ä¼°)
- [æµ‹è¯•æ–¹æ¡ˆ](#æµ‹è¯•æ–¹æ¡ˆ)
- [éƒ¨ç½²ä¸å‡çº§æŒ‡å—](#éƒ¨ç½²ä¸å‡çº§æŒ‡å—)

---

## éœ€æ±‚æ¦‚è¿°

### åŠŸèƒ½éœ€æ±‚

1. **è§’è‰²ç®¡ç†**: å¢åŠ "èŠ‚ç‚¹ç­‰çº§ç®¡ç†å‘˜"è§’è‰²ï¼ˆ`tierManager`ï¼‰
   - Owner å¯ä»¥è®¾ç½®/æ›´æ¢æ­¤è§’è‰²
   - åªæœ‰æ­¤è§’è‰²èƒ½è°ƒç”¨ç­‰çº§è®¾ç½®å‡½æ•°

2. **ç­‰çº§è®¾ç½®**: `tierManager` å¯ä¸ºç”¨æˆ·è®¾ç½®"èŠ‚ç‚¹æ¥æºç­‰çº§"
   - ä»…æ”¯æŒ V1 (1) å’Œ V2 (2)
   - è®°å½•è®¾ç½®æ—¶é—´å’Œæ“ä½œè€…

3. **ç­‰çº§è®¡ç®—é€»è¾‘**: é‡‡ç”¨"ä¿åº•æœºåˆ¶"
   ```
   æœ€ç»ˆç­‰çº§ = MAX(è‡ªç„¶ç­‰çº§, èŠ‚ç‚¹ç­‰çº§)
   ```
   - å…ˆè®¡ç®—ç”¨æˆ·çš„è‡ªç„¶ç­‰çº§ï¼ˆåŸºäº teamKPI + Preacherï¼‰
   - å¦‚æœè‡ªç„¶ç­‰çº§ < èŠ‚ç‚¹ç­‰çº§ï¼Œä½¿ç”¨èŠ‚ç‚¹ç­‰çº§
   - å¦‚æœè‡ªç„¶ç­‰çº§ â‰¥ èŠ‚ç‚¹ç­‰çº§ï¼Œä½¿ç”¨è‡ªç„¶ç­‰çº§
   - **ä¸é˜»ç¢è‡ªç„¶å‡çº§**

### è®¾è®¡ç›®æ ‡

- âœ… ä¸ç ´åç°æœ‰å‡çº§æœºåˆ¶
- âœ… èŠ‚ç‚¹ç­‰çº§ä½œä¸º"åº•çº¿ä¿éšœ"
- âœ… æƒé™åˆ†ç¦»ï¼ˆOwner â‰  ç­‰çº§ç®¡ç†å‘˜ï¼‰
- âœ… å®Œæ•´çš„äº‹ä»¶è®°å½•
- âœ… å¯è¿½æº¯æ€§

---

## è®¾è®¡æ–¹æ¡ˆ

### æ¶æ„å›¾

```mermaid
graph TB
    subgraph "è§’è‰²ç³»ç»Ÿ"
        O[Owner<br/>åˆçº¦æ‰€æœ‰è€…]
        TM[TierManager<br/>ç­‰çº§ç®¡ç†å‘˜]
    end

    subgraph "ç­‰çº§ç³»ç»Ÿ"
        NU[ç”¨æˆ·è‡ªç„¶ç­‰çº§<br/>Natural Tier]
        NT[èŠ‚ç‚¹ç­‰çº§<br/>Node Tier]
        FT[æœ€ç»ˆç­‰çº§<br/>Final Tier]
    end

    subgraph "è®¡ç®—æµç¨‹"
        C1[1. æ£€æŸ¥Preacher]
        C2[2. è®¡ç®—teamKPIç­‰çº§]
        C3[3. è·å–èŠ‚ç‚¹ç­‰çº§]
        C4[4. å–MAXå€¼]
    end

    O -->|è®¾ç½®/æ’¤é”€| TM
    TM -->|è®¾ç½®| NT

    C1 --> C2
    C2 --> NU
    C3 --> NT
    NU --> C4
    NT --> C4
    C4 --> FT

    style O fill:#ff6b6b
    style TM fill:#ffd93d
    style FT fill:#6bcf7f
```

### æ•°æ®ç»“æ„è®¾è®¡

```solidity
// èŠ‚ç‚¹ç­‰çº§è®°å½•
struct NodeTierRecord {
    uint8 tier;              // ç­‰çº§ (1 æˆ– 2)
    uint40 setTime;          // è®¾ç½®æ—¶é—´
    address setBy;           // æ“ä½œè€…åœ°å€
    bool active;             // æ˜¯å¦æ¿€æ´»
}

// çŠ¶æ€å˜é‡
address public tierManager;                              // ç­‰çº§ç®¡ç†å‘˜åœ°å€
mapping(address => NodeTierRecord) public nodeTiers;     // ç”¨æˆ·èŠ‚ç‚¹ç­‰çº§è®°å½•
```

---

## æ ¸å¿ƒé€»è¾‘

### ç­‰çº§è®¡ç®—æµç¨‹è¯¦è§£

```mermaid
flowchart TD
    Start([ç”¨æˆ·åœ°å€]) --> CheckRoot{æ˜¯å¦ä¸º<br/>rootAddress?}
    CheckRoot -->|æ˜¯| ReturnZero1[è¿”å›ç­‰çº§ 0]
    CheckRoot -->|å¦| CheckPreacher{æ˜¯å¦ä¸º<br/>Preacher?}

    CheckPreacher -->|å¦| CheckNode1{èŠ‚ç‚¹ç­‰çº§<br/>æ˜¯å¦æ¿€æ´»?}
    CheckNode1 -->|å¦| ReturnZero2[è¿”å›ç­‰çº§ 0]
    CheckNode1 -->|æ˜¯| ReturnNode1[è¿”å›èŠ‚ç‚¹ç­‰çº§<br/>ä½œä¸ºåº•çº¿]

    CheckPreacher -->|æ˜¯| CalcNatural[è®¡ç®—è‡ªç„¶ç­‰çº§<br/>åŸºäº teamKPI]
    CalcNatural --> NaturalTier[è‡ªç„¶ç­‰çº§ = N]

    NaturalTier --> CheckNode2{èŠ‚ç‚¹ç­‰çº§<br/>æ˜¯å¦æ¿€æ´»?}
    CheckNode2 -->|å¦| ReturnNatural[è¿”å›è‡ªç„¶ç­‰çº§ N]
    CheckNode2 -->|æ˜¯| CompareMax[è®¡ç®— MAX]

    CompareMax --> MaxLogic{è‡ªç„¶ç­‰çº§ >= èŠ‚ç‚¹ç­‰çº§?}
    MaxLogic -->|æ˜¯| UsNatural[ä½¿ç”¨è‡ªç„¶ç­‰çº§<br/>å…è®¸è‡ªç„¶å‡çº§]
    MaxLogic -->|å¦| UseNode[ä½¿ç”¨èŠ‚ç‚¹ç­‰çº§<br/>ä¿åº•æœºåˆ¶ç”Ÿæ•ˆ]

    UsNatural --> FinalTier[æœ€ç»ˆç­‰çº§]
    UseNode --> FinalTier
    ReturnNatural --> FinalTier
    ReturnNode1 --> FinalTier
    ReturnZero1 --> FinalTier
    ReturnZero2 --> FinalTier

    style ReturnZero1 fill:#ff6b6b
    style ReturnZero2 fill:#ff6b6b
    style FinalTier fill:#6bcf7f
    style UseNode fill:#ffd93d
```

### å…³é”®åœºæ™¯åˆ†æ

#### åœºæ™¯ 1: é Preacher ç”¨æˆ·

```
ç”¨æˆ·çŠ¶æ€:
- è´¨æŠ¼: 100 SYI (< 200 SYI)
- teamKPI: 20,000 USDT
- èŠ‚ç‚¹ç­‰çº§: V1

è®¡ç®—è¿‡ç¨‹:
1. isPreacher(user) = false
2. æ£€æŸ¥èŠ‚ç‚¹ç­‰çº§: nodeTiers[user].active = true
3. è¿”å›: 0 (å› ä¸ºä¸æ»¡è¶³ Preacher æ¡ä»¶)

ç»“è®º: èŠ‚ç‚¹ç­‰çº§ä¸èƒ½ç»•è¿‡ Preacher æ£€æŸ¥
```

#### åœºæ™¯ 2: èŠ‚ç‚¹ç­‰çº§ä½œä¸ºåº•çº¿

```
ç”¨æˆ·çŠ¶æ€:
- è´¨æŠ¼: 300 SYI (Preacher âœ“)
- teamKPI: 5,000 USDT (ä¸è¶³ V1 é—¨æ§› 10,000)
- èŠ‚ç‚¹ç­‰çº§: V1

è®¡ç®—è¿‡ç¨‹:
1. isPreacher(user) = true
2. è‡ªç„¶ç­‰çº§ = 0 (teamKPI ä¸è¶³)
3. èŠ‚ç‚¹ç­‰çº§ = 1
4. MAX(0, 1) = 1

ç»“è®º: ä½¿ç”¨èŠ‚ç‚¹ç­‰çº§ V1
```

#### åœºæ™¯ 3: è‡ªç„¶å‡çº§ä¼˜å…ˆ

```
ç”¨æˆ·çŠ¶æ€:
- è´¨æŠ¼: 500 SYI (Preacher âœ“)
- teamKPI: 250,000 USDT (è¾¾åˆ° V3 é—¨æ§›)
- èŠ‚ç‚¹ç­‰çº§: V1

è®¡ç®—è¿‡ç¨‹:
1. isPreacher(user) = true
2. è‡ªç„¶ç­‰çº§ = 3 (teamKPI â‰¥ 200,000)
3. èŠ‚ç‚¹ç­‰çº§ = 1
4. MAX(3, 1) = 3

ç»“è®º: ä½¿ç”¨è‡ªç„¶ç­‰çº§ V3 (èŠ‚ç‚¹ç­‰çº§ä¸é™åˆ¶å‡çº§)
```

#### åœºæ™¯ 4: èŠ‚ç‚¹ç­‰çº§è¢«æ’¤é”€

```
ç”¨æˆ·çŠ¶æ€:
- è´¨æŠ¼: 300 SYI
- teamKPI: 8,000 USDT
- èŠ‚ç‚¹ç­‰çº§: å·²æ’¤é”€ (active = false)

è®¡ç®—è¿‡ç¨‹:
1. isPreacher(user) = true
2. è‡ªç„¶ç­‰çº§ = 0
3. nodeTiers[user].active = false
4. è¿”å›è‡ªç„¶ç­‰çº§ = 0

ç»“è®º: å¤±å»èŠ‚ç‚¹ç­‰çº§ä¿éšœ
```

---

## å®Œæ•´å®ç°ä»£ç 

### 1. ä¿®æ”¹ `StakingBase.sol`

#### 1.1 æ·»åŠ çŠ¶æ€å˜é‡ï¼ˆç¬¬ 134 è¡Œåï¼‰

```solidity
// =========================================================================
// NODE TIER MANAGEMENT SYSTEM
// =========================================================================

/**
 * @notice èŠ‚ç‚¹ç­‰çº§ç®¡ç†å‘˜åœ°å€
 * @dev åªæœ‰æ­¤åœ°å€å¯ä»¥è®¾ç½®ç”¨æˆ·çš„èŠ‚ç‚¹ç­‰çº§
 */
address public tierManager;

/**
 * @notice èŠ‚ç‚¹ç­‰çº§è®°å½•ç»“æ„
 * @param tier ç­‰çº§ (1=V1, 2=V2)
 * @param setTime è®¾ç½®æ—¶é—´æˆ³
 * @param setBy è®¾ç½®æ“ä½œè€…åœ°å€
 * @param active æ˜¯å¦æ¿€æ´»
 */
struct NodeTierRecord {
    uint8 tier;
    uint40 setTime;
    address setBy;
    bool active;
}

/**
 * @notice ç”¨æˆ·èŠ‚ç‚¹ç­‰çº§æ˜ å°„
 */
mapping(address => NodeTierRecord) public nodeTiers;
```

#### 1.2 æ·»åŠ äº‹ä»¶ï¼ˆç¬¬ 155 è¡Œåï¼‰

```solidity
// Node Tier Management Events
event TierManagerUpdated(
    address indexed oldManager,
    address indexed newManager,
    address indexed operator,
    uint256 timestamp
);

event NodeTierSet(
    address indexed user,
    uint8 tier,
    address indexed setBy,
    uint256 timestamp
);

event NodeTierRemoved(
    address indexed user,
    uint8 previousTier,
    address indexed removedBy,
    uint256 timestamp
);

event NodeTierBatchSet(
    address[] users,
    uint8[] tiers,
    address indexed setBy,
    uint256 count,
    uint256 timestamp
);

event NodeTierUsed(
    address indexed user,
    uint8 naturalTier,
    uint8 nodeTier,
    uint8 finalTier,
    string reason
);
```

#### 1.3 æ·»åŠ ä¿®é¥°å™¨ï¼ˆç¬¬ 165 è¡Œåï¼‰

```solidity
/**
 * @notice é™åˆ¶åªæœ‰ tierManager å¯ä»¥è°ƒç”¨
 */
modifier onlyTierManager() {
    require(msg.sender == tierManager, "Caller is not tier manager");
    _;
}
```

#### 1.4 ä¿®æ”¹æ„é€ å‡½æ•°ï¼ˆç¬¬ 176 è¡Œï¼‰

```solidity
constructor(
    address _usdt,
    address _router,
    address _rootAddress,
    address _feeRecipient
) Ownable(msg.sender) {
    require(_usdt != address(0), "Invalid USDT address");
    require(_router != address(0), "Invalid router address");

    USDT = _usdt;
    ROUTER = IUniswapV2Router02(_router);
    rootAddress = _rootAddress;
    feeRecipient = _feeRecipient;

    // åˆå§‹åŒ– tierManager ä¸º owner
    tierManager = msg.sender;

    IERC20(_usdt).approve(_router, type(uint256).max);
    _updateRatesForMode();
}
```

#### 1.5 æ·»åŠ ç®¡ç†å‡½æ•°ï¼ˆç¬¬ 1420 è¡Œåï¼‰

```solidity
// =========================================================================
// NODE TIER MANAGEMENT FUNCTIONS
// =========================================================================

/**
 * @notice è®¾ç½®èŠ‚ç‚¹ç­‰çº§ç®¡ç†å‘˜åœ°å€
 * @param _tierManager æ–°çš„ç®¡ç†å‘˜åœ°å€
 * @dev åªèƒ½ç”± owner è°ƒç”¨ï¼Œ0åœ°å€è¡¨ç¤ºç¦ç”¨åŠŸèƒ½
 */
function setTierManager(address _tierManager) external onlyOwner {
    address oldManager = tierManager;
    tierManager = _tierManager;

    emit TierManagerUpdated(
        oldManager,
        _tierManager,
        msg.sender,
        block.timestamp
    );
}

/**
 * @notice ä¸ºç”¨æˆ·è®¾ç½®èŠ‚ç‚¹ç­‰çº§ï¼ˆV1æˆ–V2ï¼‰
 * @param user ç›®æ ‡ç”¨æˆ·åœ°å€
 * @param tier ç­‰çº§ (1=V1, 2=V2)
 * @dev åªèƒ½ç”± tierManager è°ƒç”¨
 * @dev èŠ‚ç‚¹ç­‰çº§ä½œä¸ºæœ€ä½ä¿éšœï¼Œä¸é™åˆ¶è‡ªç„¶å‡çº§
 */
function setNodeTier(
    address user,
    uint8 tier
) external onlyTierManager {
    require(user != address(0), "NodeTier: invalid address");
    require(user != rootAddress, "NodeTier: cannot set for root");
    require(tier >= 1 && tier <= 2, "NodeTier: only tier 1 or 2 allowed");

    nodeTiers[user] = NodeTierRecord({
        tier: tier,
        setTime: uint40(block.timestamp),
        setBy: msg.sender,
        active: true
    });

    emit NodeTierSet(user, tier, msg.sender, block.timestamp);
}

/**
 * @notice ç§»é™¤ç”¨æˆ·çš„èŠ‚ç‚¹ç­‰çº§
 * @param user ç›®æ ‡ç”¨æˆ·åœ°å€
 * @dev åªèƒ½ç”± tierManager è°ƒç”¨
 */
function removeNodeTier(address user) external onlyTierManager {
    require(nodeTiers[user].active, "NodeTier: no active tier");

    uint8 previousTier = nodeTiers[user].tier;
    nodeTiers[user].active = false;

    emit NodeTierRemoved(user, previousTier, msg.sender, block.timestamp);
}

/**
 * @notice æ‰¹é‡è®¾ç½®èŠ‚ç‚¹ç­‰çº§
 * @param users ç”¨æˆ·åœ°å€æ•°ç»„
 * @param tiers å¯¹åº”ç­‰çº§æ•°ç»„
 * @dev åªèƒ½ç”± tierManager è°ƒç”¨
 * @dev æœ€å¤šä¸€æ¬¡å¤„ç† 100 ä¸ªç”¨æˆ·
 */
function batchSetNodeTier(
    address[] calldata users,
    uint8[] calldata tiers
) external onlyTierManager {
    require(users.length == tiers.length, "NodeTier: array length mismatch");
    require(users.length > 0, "NodeTier: empty array");
    require(users.length <= 100, "NodeTier: max 100 users per batch");

    for (uint256 i = 0; i < users.length; ) {
        address user = users[i];
        uint8 tier = tiers[i];

        require(user != address(0), "NodeTier: invalid address in batch");
        require(user != rootAddress, "NodeTier: cannot set for root");
        require(tier >= 1 && tier <= 2, "NodeTier: invalid tier in batch");

        nodeTiers[user] = NodeTierRecord({
            tier: tier,
            setTime: uint40(block.timestamp),
            setBy: msg.sender,
            active: true
        });

        emit NodeTierSet(user, tier, msg.sender, block.timestamp);

        unchecked {
            ++i;
        }
    }

    emit NodeTierBatchSet(users, tiers, msg.sender, users.length, block.timestamp);
}

/**
 * @notice æ‰¹é‡ç§»é™¤èŠ‚ç‚¹ç­‰çº§
 * @param users ç”¨æˆ·åœ°å€æ•°ç»„
 * @dev åªèƒ½ç”± tierManager è°ƒç”¨
 */
function batchRemoveNodeTier(
    address[] calldata users
) external onlyTierManager {
    require(users.length > 0, "NodeTier: empty array");
    require(users.length <= 100, "NodeTier: max 100 users per batch");

    for (uint256 i = 0; i < users.length; ) {
        address user = users[i];
        if (nodeTiers[user].active) {
            uint8 previousTier = nodeTiers[user].tier;
            nodeTiers[user].active = false;
            emit NodeTierRemoved(user, previousTier, msg.sender, block.timestamp);
        }

        unchecked {
            ++i;
        }
    }
}

// =========================================================================
// NODE TIER QUERY FUNCTIONS
// =========================================================================

/**
 * @notice æŸ¥è¯¢ç”¨æˆ·çš„èŠ‚ç‚¹ç­‰çº§è¯¦æƒ…
 * @param user ç”¨æˆ·åœ°å€
 * @return hasNodeTier æ˜¯å¦è®¾ç½®äº†èŠ‚ç‚¹ç­‰çº§
 * @return tier èŠ‚ç‚¹ç­‰çº§
 * @return setTime è®¾ç½®æ—¶é—´
 * @return setBy è®¾ç½®è€…åœ°å€
 * @return isActive æ˜¯å¦æ¿€æ´»
 */
function getNodeTierDetails(
    address user
) external view returns (
    bool hasNodeTier,
    uint8 tier,
    uint40 setTime,
    address setBy,
    bool isActive
) {
    NodeTierRecord memory record = nodeTiers[user];
    hasNodeTier = record.tier > 0;
    tier = record.tier;
    setTime = record.setTime;
    setBy = record.setBy;
    isActive = record.active;
}

/**
 * @notice æŸ¥è¯¢ç”¨æˆ·çš„å®Œæ•´ç­‰çº§ä¿¡æ¯
 * @param user ç”¨æˆ·åœ°å€
 * @return isPreacherStatus æ˜¯å¦ä¸º Preacher
 * @return naturalTier è‡ªç„¶ç­‰çº§ (åŸºäº teamKPI)
 * @return nodeTier èŠ‚ç‚¹ç­‰çº§
 * @return finalTier æœ€ç»ˆç­‰çº§ (å®é™…ç”Ÿæ•ˆ)
 * @return usingNodeTier æ˜¯å¦ä½¿ç”¨äº†èŠ‚ç‚¹ç­‰çº§
 */
function getUserTierBreakdown(
    address user
) external view returns (
    bool isPreacherStatus,
    uint8 naturalTier,
    uint8 nodeTier,
    uint8 finalTier,
    bool usingNodeTier
) {
    isPreacherStatus = isPreacher(user);

    // è®¡ç®—è‡ªç„¶ç­‰çº§ï¼ˆä¸è€ƒè™‘èŠ‚ç‚¹ç­‰çº§ï¼‰
    naturalTier = _calculateNaturalTier(user);

    // è·å–èŠ‚ç‚¹ç­‰çº§
    NodeTierRecord memory record = nodeTiers[user];
    nodeTier = (record.active && isPreacherStatus) ? record.tier : 0;

    // æœ€ç»ˆç­‰çº§ï¼ˆé€šè¿‡ _getUserTier è·å–ï¼‰
    finalTier = _getUserTier(user);

    // åˆ¤æ–­æ˜¯å¦ä½¿ç”¨äº†èŠ‚ç‚¹ç­‰çº§
    usingNodeTier = (nodeTier > 0 && finalTier == nodeTier && naturalTier < nodeTier);
}
```

#### 1.6 ä¿®æ”¹ `_getUserTier` å‡½æ•°ï¼ˆç¬¬ 1255-1273 è¡Œï¼‰

**åŸå‡½æ•°**:
```solidity
function _getUserTier(address user) private view returns (uint8 tier) {
    if (user == rootAddress || !isPreacher(user)) {
        return 0;
    }

    uint256 teamKPI = getTeamKpi(user);
    IStaking.TeamTier[7] memory tiers = _getTeamTiers();

    for (uint256 i = 0; i < tiers.length; ) {
        if (teamKPI >= tiers[i].threshold) {
            return uint8(7 - i);
        }
        unchecked {
            ++i;
        }
    }

    return 0;
}
```

**ä¿®æ”¹å**:
```solidity
/**
 * @notice è®¡ç®—ç”¨æˆ·çš„æœ€ç»ˆç­‰çº§
 * @param user ç”¨æˆ·åœ°å€
 * @return tier æœ€ç»ˆç­‰çº§ (0-7)
 * @dev é€»è¾‘ï¼šMAX(è‡ªç„¶ç­‰çº§, èŠ‚ç‚¹ç­‰çº§)
 * @dev èŠ‚ç‚¹ç­‰çº§ä½œä¸ºæœ€ä½ä¿éšœï¼Œä¸é™åˆ¶è‡ªç„¶å‡çº§
 */
function _getUserTier(address user) private view returns (uint8 tier) {
    // 1. rootAddress æ°¸è¿œè¿”å› 0
    if (user == rootAddress) {
        return 0;
    }

    // 2. é Preacher ç”¨æˆ·è¿”å› 0ï¼ˆèŠ‚ç‚¹ç­‰çº§ä¹Ÿæ— æ•ˆï¼‰
    if (!isPreacher(user)) {
        return 0;
    }

    // 3. è®¡ç®—è‡ªç„¶ç­‰çº§ï¼ˆåŸºäº teamKPIï¼‰
    uint8 naturalTier = _calculateNaturalTier(user);

    // 4. æ£€æŸ¥èŠ‚ç‚¹ç­‰çº§
    NodeTierRecord memory record = nodeTiers[user];
    uint8 nodeTier = record.active ? record.tier : 0;

    // 5. å–æœ€å¤§å€¼
    uint8 finalTier = _max8(naturalTier, nodeTier);

    // 6. è®°å½•ä½¿ç”¨æƒ…å†µï¼ˆä»…ç”¨äºè¿½è¸ªï¼‰
    if (nodeTier > 0 && finalTier > naturalTier) {
        emit NodeTierUsed(
            user,
            naturalTier,
            nodeTier,
            finalTier,
            "Node tier used as floor"
        );
    }

    return finalTier;
}

/**
 * @notice è®¡ç®—ç”¨æˆ·çš„è‡ªç„¶ç­‰çº§ï¼ˆä¸è€ƒè™‘èŠ‚ç‚¹ç­‰çº§ï¼‰
 * @param user ç”¨æˆ·åœ°å€
 * @return tier è‡ªç„¶ç­‰çº§ (0-7)
 * @dev çº¯ç²¹åŸºäº teamKPI è®¡ç®—
 */
function _calculateNaturalTier(address user) private view returns (uint8 tier) {
    // rootAddress æˆ–é Preacher è¿”å› 0
    if (user == rootAddress || !isPreacher(user)) {
        return 0;
    }

    uint256 teamKPI = getTeamKpi(user);
    IStaking.TeamTier[7] memory tiers = _getTeamTiers();

    for (uint256 i = 0; i < tiers.length; ) {
        if (teamKPI >= tiers[i].threshold) {
            return uint8(7 - i);
        }
        unchecked {
            ++i;
        }
    }

    return 0;
}

/**
 * @notice è¿”å›ä¸¤ä¸ª uint8 çš„æœ€å¤§å€¼
 */
function _max8(uint8 a, uint8 b) private pure returns (uint8) {
    return a >= b ? a : b;
}
```

---

## å½±å“åˆ†æ

### 3.1 ç›´æ¥å½±å“çš„å‡½æ•°

#### ğŸ”´ é«˜å½±å“ï¼šéœ€è¦éªŒè¯

| å‡½æ•°å | ä½ç½® | è°ƒç”¨ `_getUserTier` | å½±å“æè¿° |
|--------|------|---------------------|----------|
| `_distributeHybridRewards` | `StakingBase.sol:1080` | âœ… æ˜¯ | å›¢é˜Ÿå¥–åŠ±åˆ†å‘æ ¸å¿ƒé€»è¾‘ |
| `getTeamPerformanceDetails` | `StakingBase.sol:677` | âœ… æ˜¯ | å›¢é˜Ÿç»©æ•ˆæŸ¥è¯¢ |

#### ğŸŸ¡ ä¸­å½±å“ï¼šé—´æ¥ä¾èµ–

| å‡½æ•°å | ä½ç½® | ä¾èµ–å…³ç³» | å½±å“æè¿° |
|--------|------|----------|----------|
| `_distributeTeamReward` | `StakingBase.sol:1014` | è°ƒç”¨ `_distributeHybridRewards` | unstake æ—¶åˆ†å‘å¥–åŠ± |
| `unstake` | `StakingBase.sol:200` | è°ƒç”¨ `_distributeTeamReward` | ç”¨æˆ·è§£è´¨æŠ¼å…¥å£ |

### 3.2 å½±å“è¯¦ç»†åˆ†æ

#### å½±å“ 1: å›¢é˜Ÿå¥–åŠ±åˆ†å‘é€»è¾‘

**ä»£ç ä½ç½®**: `StakingBase.sol:1104-1164`

```solidity
function _distributeHybridRewards(...) private returns (...) {
    // ...
    for (uint256 i = 0; i < referralChain.length; ) {
        uint8 currentTier = memberTiers[i];  // â† è¿™é‡Œè·å–çš„æ˜¯ _getUserTier çš„ç»“æœ

        if (
            currentTier > 0 &&
            !tierAllocated[currentTier] &&
            isPreacher(referralChain[i])  // â† é‡å¤æ£€æŸ¥ Preacher
        ) {
            // åˆ†å‘å¥–åŠ±
        }
    }
}
```

**å½±å“åˆ†æ**:

âœ… **æ­£å‘å½±å“**:
- èŠ‚ç‚¹ç­‰çº§ç”¨æˆ·å¯ä»¥è·å¾—å¯¹åº”ç­‰çº§çš„å›¢é˜Ÿå¥–åŠ±
- å³ä½¿ teamKPI ä¸è¶³ï¼Œä¹Ÿèƒ½è·å¾— V1/V2 çš„å¥–åŠ±

âš ï¸ **æ½œåœ¨é—®é¢˜**:
- `isPreacher` è¢«æ£€æŸ¥äº†ä¸¤æ¬¡ï¼ˆ`_getUserTier` å†…éƒ¨ + `_distributeHybridRewards` å†…éƒ¨ï¼‰
- **ç»“è®º**: æ— é—®é¢˜ï¼Œå†—ä½™æ£€æŸ¥å¢åŠ å®‰å…¨æ€§

**æµ‹è¯•åœºæ™¯**:
```
ç”¨æˆ·A: èŠ‚ç‚¹ç­‰çº§ V1, è‡ªç„¶ç­‰çº§ 0
ä¸‹çº§B è§£è´¨æŠ¼ï¼Œåˆ©æ¯ 1000 USDT

é¢„æœŸ:
- A è·å¾— 1000 Ã— 5% = 50 USDT (V1 å¥–åŠ±)
- å‰©ä½™ 300 USDT ç»™ rootAddress
```

---

#### å½±å“ 2: å›¢é˜Ÿç»©æ•ˆæŸ¥è¯¢

**ä»£ç ä½ç½®**: `StakingBase.sol:677-704`

```solidity
function getTeamPerformanceDetails(
    address _user
) external view returns (
    uint256 totalTeamInvestment,
    uint256 teamMemberCount,
    uint8 currentTier,  // â† è¿”å›æœ€ç»ˆç­‰çº§
    uint256 nextTierThreshold,
    uint256 progressToNextTier
) {
    // ...
    currentTier = _getUserTier(_user);  // â† åŒ…å«èŠ‚ç‚¹ç­‰çº§çš„æœ€ç»ˆç­‰çº§
    // ...
}
```

**å½±å“åˆ†æ**:

âš ï¸ **æ½œåœ¨è¯¯å¯¼**:
- å¦‚æœç”¨æˆ·ä½¿ç”¨èŠ‚ç‚¹ç­‰çº§ï¼Œ`currentTier` ä¼šæ˜¾ç¤º V1/V2
- ä½† `totalTeamInvestment` å¯èƒ½ä¸è¶³å¯¹åº”é—¨æ§›
- ç”¨æˆ·å¯èƒ½å›°æƒ‘ï¼š"æˆ‘æ€ä¹ˆæ˜¯ V1 ä½† teamKPI æ‰ 5000ï¼Ÿ"

âœ… **è§£å†³æ–¹æ¡ˆ**:
- ä½¿ç”¨æ–°å‡½æ•° `getUserTierBreakdown` æŸ¥è¯¢è¯¦æƒ…
- å‰ç«¯åº”åŒºåˆ†æ˜¾ç¤º"è‡ªç„¶ç­‰çº§"å’Œ"èŠ‚ç‚¹ç­‰çº§"

**å»ºè®®å‰ç«¯æ˜¾ç¤º**:
```
å½“å‰ç­‰çº§: V1 â­ (èŠ‚ç‚¹ç­‰çº§)
è‡ªç„¶ç­‰çº§: V0 (teamKPI: 5,000 / 10,000)
è·ç¦» V1: 5,000 USDT
```

---

### 3.3 ä¸å—å½±å“çš„å‡½æ•°

ä»¥ä¸‹å‡½æ•°**ä¸è°ƒç”¨** `_getUserTier`ï¼Œå› æ­¤**å®Œå…¨ä¸å—å½±å“**:

| å‡½æ•°å | åŠŸèƒ½ | åŸå›  |
|--------|------|------|
| `stake` | è´¨æŠ¼ | ä¸æ¶‰åŠç­‰çº§è®¡ç®— |
| `lockReferral` | ç»‘å®šæ¨èäºº | ä¸æ¶‰åŠç­‰çº§è®¡ç®— |
| `_updateTeamInvestmentValues` | æ›´æ–° teamKPI | ä»…ä¿®æ”¹ KPIï¼Œä¸æŸ¥è¯¢ç­‰çº§ |
| `isPreacher` | Preacher æ£€æŸ¥ | ç‹¬ç«‹é€»è¾‘ |
| `getTeamKpi` | æŸ¥è¯¢ teamKPI | è¿”å›åŸå§‹ KPI å€¼ |
| `balanceOf` | æŸ¥è¯¢ä½™é¢ | ä¸æ¶‰åŠç­‰çº§ |

---

### 3.4 å­˜å‚¨å¸ƒå±€å½±å“

**æ–°å¢çŠ¶æ€å˜é‡**:
```solidity
address public tierManager;                     // 20 bytes
mapping(address => NodeTierRecord) public nodeTiers;  // åŠ¨æ€å¤§å°
```

**NodeTierRecord å¤§å°**:
```solidity
struct NodeTierRecord {
    uint8 tier;        // 1 byte
    uint40 setTime;    // 5 bytes
    address setBy;     // 20 bytes
    bool active;       // 1 byte
}
// æ€»è®¡: 27 bytes (æ‰“åŒ…åå ç”¨ 1 ä¸ª slot)
```

âœ… **å½±å“è¯„ä¼°**:
- æ¯ä¸ªç”¨æˆ·å¢åŠ  **1 ä¸ª storage slot** (32 bytes)
- Gas æˆæœ¬: è®¾ç½®èŠ‚ç‚¹ç­‰çº§ ~20,000 gas
- **ç»“è®º**: å½±å“å¯æ¥å—

---

### 3.5 äº‹ä»¶æ—¥å¿—å½±å“

**æ–°å¢äº‹ä»¶**:
- `TierManagerUpdated`: ç®¡ç†å‘˜å˜æ›´
- `NodeTierSet`: è®¾ç½®èŠ‚ç‚¹ç­‰çº§
- `NodeTierRemoved`: ç§»é™¤èŠ‚ç‚¹ç­‰çº§
- `NodeTierBatchSet`: æ‰¹é‡è®¾ç½®
- `NodeTierUsed`: èŠ‚ç‚¹ç­‰çº§ç”Ÿæ•ˆ

âœ… **å½±å“**:
- å¢å¼ºå¯è¿½æº¯æ€§
- æ–¹ä¾¿å‰ç«¯ç›‘å¬
- ä¸å½±å“ç°æœ‰åŠŸèƒ½

---

### 3.6 Gas æˆæœ¬å½±å“

| æ“ä½œ | åŸå§‹ Gas | ä¿®æ”¹å Gas | å¢åŠ  | åŸå›  |
|------|----------|-----------|------|------|
| `unstake` (æ— èŠ‚ç‚¹ç­‰çº§) | ~450,000 | ~452,000 | +2,000 | é¢å¤–çš„ SLOAD |
| `unstake` (ä½¿ç”¨èŠ‚ç‚¹ç­‰çº§) | ~450,000 | ~453,000 | +3,000 | SLOAD + emit |
| `setNodeTier` | - | ~45,000 | - | SSTORE + emit |
| `batchSetNodeTier` (10ä¸ª) | - | ~250,000 | - | æ‰¹é‡ SSTORE |

âœ… **ç»“è®º**: Gas å¢åŠ  < 1%ï¼Œå¯æ¥å—

---

### 3.7 å®‰å…¨æ€§å½±å“

#### é£é™© 1: æƒé™æ»¥ç”¨

**åœºæ™¯**: tierManager æ¶æ„ç»™å¤§é‡åœ°å€è®¾ç½® V2
**å½±å“**:
- è¿™äº›åœ°å€å¯ä»¥è·å¾— 10% çš„å›¢é˜Ÿå¥–åŠ±
- æŸå®³å…¶ä»–é«˜ç­‰çº§ç”¨æˆ·åˆ©ç›Š
- é¡¹ç›®æ–¹æ”¶ç›Šå‡å°‘

**ç¼“è§£æªæ–½**:
1. âœ… Owner å¯éšæ—¶æ›´æ¢ tierManager
2. âœ… æ‰€æœ‰æ“ä½œæœ‰äº‹ä»¶è®°å½•ï¼Œå¯è¿½æº¯
3. âœ… ä»…é™ V1/V2ï¼Œæ— æ³•è®¾ç½®æ›´é«˜ç­‰çº§
4. âœ… ä»éœ€æ»¡è¶³ Preacher æ¡ä»¶ï¼ˆ200 SYIï¼‰

#### é£é™© 2: Preacher æ¡ä»¶å¤±æ•ˆ

**åœºæ™¯**: ç”¨æˆ·è·å¾—èŠ‚ç‚¹ç­‰çº§åè§£é™¤è´¨æŠ¼
**å½±å“**: å¤±å» Preacher èµ„æ ¼ï¼ŒèŠ‚ç‚¹ç­‰çº§æ— æ•ˆ

**è®¾è®¡å†³ç­–**:
- âœ… **ä¿ç•™æ­¤è¡Œä¸º**
- åŸå› : é˜²æ­¢ç”¨æˆ·"ç™½å«–"ï¼ˆæ‹¿åˆ°èŠ‚ç‚¹ç­‰çº§åç«‹å³æå¸ï¼‰
- è¦æ±‚: å¿…é¡»æŒç»­è´¨æŠ¼ â‰¥ 200 SYI

#### é£é™© 3: ç­‰çº§å»é‡æœºåˆ¶

**åœºæ™¯**: æ¨èé“¾ä¸­å¤šä¸ªç”¨æˆ·æœ‰ç›¸åŒèŠ‚ç‚¹ç­‰çº§
**å½±å“**: ç¬¬ä¸€ä¸ªé‡åˆ°çš„ç”¨æˆ·è·å¾—å¥–åŠ±

**ä»£ç éªŒè¯**:
```solidity
// StakingBase.sol:1147
tierAllocated[currentTier] = true;  // â† é˜²æ­¢é‡å¤åˆ†é…
```

âœ… **ç»“è®º**: ç°æœ‰æœºåˆ¶å·²è¦†ç›–

---

## å®‰å…¨é£é™©è¯„ä¼°

### é£é™©çŸ©é˜µ

| é£é™©ç±»å‹ | æ¦‚ç‡ | å½±å“ | ç­‰çº§ | ç¼“è§£æªæ–½ |
|----------|------|------|------|----------|
| tierManager æ¶æ„æ“ä½œ | ä¸­ | é«˜ | ğŸŸ¡ ä¸­ | äº‹ä»¶è®°å½• + Owner å¯æ’¤æ¢ |
| æƒé™ç®¡ç†æ¼æ´ | ä½ | é«˜ | ğŸŸ¢ ä½ | ä½¿ç”¨ OpenZeppelin Ownable |
| ç­‰çº§è®¡ç®—é”™è¯¯ | ä½ | é«˜ | ğŸŸ¢ ä½ | è¯¦ç»†æµ‹è¯• + æŸ¥è¯¢å‡½æ•°éªŒè¯ |
| Gas æ”»å‡»ï¼ˆæ‰¹é‡æ“ä½œï¼‰| ä½ | ä½ | ğŸŸ¢ ä½ | é™åˆ¶æ‰¹é‡ä¸Šé™ 100 |
| é‡å…¥æ”»å‡» | æä½ | é«˜ | ğŸŸ¢ ä½ | æ— å¤–éƒ¨è°ƒç”¨ |
| æ•´æ•°æº¢å‡º | æä½ | é«˜ | ğŸŸ¢ ä½ | Solidity 0.8+ è‡ªåŠ¨æ£€æŸ¥ |

### å®¡è®¡å»ºè®®

**é‡ç‚¹å®¡è®¡é¡¹**:
1. `_getUserTier` çš„ MAX é€»è¾‘
2. `_distributeHybridRewards` çš„ç­‰çº§å»é‡
3. `onlyTierManager` ä¿®é¥°å™¨
4. æ‰¹é‡æ“ä½œçš„ Gas ä¸Šé™

**æ¨èå®¡è®¡å·¥å…·**:
- Slither (é™æ€åˆ†æ)
- Mythril (ç¬¦å·æ‰§è¡Œ)
- Echidna (æ¨¡ç³Šæµ‹è¯•)

---

## æµ‹è¯•æ–¹æ¡ˆ

### 5.1 å•å…ƒæµ‹è¯•

#### æµ‹è¯•æ–‡ä»¶: `test/NodeTierManagement.test.js`

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("èŠ‚ç‚¹ç­‰çº§ç®¡ç†ç³»ç»Ÿ", function() {
    let staking, owner, tierManager, user1, user2, root;

    beforeEach(async function() {
        [owner, tierManager, user1, user2, root] = await ethers.getSigners();

        // éƒ¨ç½²åˆçº¦ï¼ˆå‡è®¾å·²éƒ¨ç½² USDT, Router ç­‰ï¼‰
        const Staking = await ethers.getContractFactory("Staking");
        staking = await Staking.deploy(usdt, router, root.address, root.address);

        // è®¾ç½® tierManager
        await staking.setTierManager(tierManager.address);
    });

    describe("1. è§’è‰²ç®¡ç†", function() {
        it("åº”è¯¥æ­£ç¡®è®¾ç½® tierManager", async function() {
            expect(await staking.tierManager()).to.equal(tierManager.address);
        });

        it("é owner ä¸èƒ½è®¾ç½® tierManager", async function() {
            await expect(
                staking.connect(user1).setTierManager(user1.address)
            ).to.be.revertedWith("Ownable: caller is not the owner");
        });

        it("åº”è¯¥èƒ½æ›´æ¢ tierManager", async function() {
            await staking.setTierManager(user1.address);
            expect(await staking.tierManager()).to.equal(user1.address);
        });

        it("è®¾ç½® tierManager åº”è§¦å‘äº‹ä»¶", async function() {
            await expect(staking.setTierManager(user1.address))
                .to.emit(staking, "TierManagerUpdated")
                .withArgs(tierManager.address, user1.address, owner.address);
        });
    });

    describe("2. è®¾ç½®èŠ‚ç‚¹ç­‰çº§", function() {
        it("tierManager åº”è¯¥èƒ½è®¾ç½®èŠ‚ç‚¹ç­‰çº§", async function() {
            await staking.connect(tierManager).setNodeTier(user1.address, 1);

            const details = await staking.getNodeTierDetails(user1.address);
            expect(details.hasNodeTier).to.be.true;
            expect(details.tier).to.equal(1);
            expect(details.isActive).to.be.true;
        });

        it("é tierManager ä¸èƒ½è®¾ç½®èŠ‚ç‚¹ç­‰çº§", async function() {
            await expect(
                staking.connect(user1).setNodeTier(user2.address, 1)
            ).to.be.revertedWith("Caller is not tier manager");
        });

        it("åº”æ‹’ç»æ— æ•ˆç­‰çº§", async function() {
            await expect(
                staking.connect(tierManager).setNodeTier(user1.address, 0)
            ).to.be.revertedWith("NodeTier: only tier 1 or 2 allowed");

            await expect(
                staking.connect(tierManager).setNodeTier(user1.address, 3)
            ).to.be.revertedWith("NodeTier: only tier 1 or 2 allowed");
        });

        it("åº”æ‹’ç»ä¸º rootAddress è®¾ç½®", async function() {
            await expect(
                staking.connect(tierManager).setNodeTier(root.address, 1)
            ).to.be.revertedWith("NodeTier: cannot set for root");
        });

        it("è®¾ç½®èŠ‚ç‚¹ç­‰çº§åº”è§¦å‘äº‹ä»¶", async function() {
            await expect(
                staking.connect(tierManager).setNodeTier(user1.address, 1)
            ).to.emit(staking, "NodeTierSet")
              .withArgs(user1.address, 1, tierManager.address);
        });
    });

    describe("3. ç­‰çº§è®¡ç®—é€»è¾‘", function() {
        beforeEach(async function() {
            // user1 è´¨æŠ¼ 300 SYI æˆä¸º Preacher
            await staking.connect(user1).stake(ethers.parseEther("300"), 0);
        });

        it("åœºæ™¯1: æ— èŠ‚ç‚¹ç­‰çº§ï¼Œæ—  teamKPI", async function() {
            const breakdown = await staking.getUserTierBreakdown(user1.address);
            expect(breakdown.naturalTier).to.equal(0);
            expect(breakdown.nodeTier).to.equal(0);
            expect(breakdown.finalTier).to.equal(0);
            expect(breakdown.usingNodeTier).to.be.false;
        });

        it("åœºæ™¯2: æœ‰èŠ‚ç‚¹ç­‰çº§ V1ï¼Œæ—  teamKPI", async function() {
            await staking.connect(tierManager).setNodeTier(user1.address, 1);

            const breakdown = await staking.getUserTierBreakdown(user1.address);
            expect(breakdown.naturalTier).to.equal(0);
            expect(breakdown.nodeTier).to.equal(1);
            expect(breakdown.finalTier).to.equal(1);  // ä½¿ç”¨èŠ‚ç‚¹ç­‰çº§
            expect(breakdown.usingNodeTier).to.be.true;
        });

        it("åœºæ™¯3: èŠ‚ç‚¹ç­‰çº§ V1ï¼Œè‡ªç„¶ç­‰çº§ V3", async function() {
            // æ¨¡æ‹Ÿ user1 çš„ teamKPI è¾¾åˆ° 250,000 (V3)
            // è¿™éœ€è¦ä¿®æ”¹åˆçº¦çŠ¶æ€æˆ–ä½¿ç”¨ mock
            // å‡è®¾å·²è®¾ç½® teamTotalInvestValue[user1] = 250,000 ether

            await staking.connect(tierManager).setNodeTier(user1.address, 1);

            const breakdown = await staking.getUserTierBreakdown(user1.address);
            expect(breakdown.naturalTier).to.equal(3);
            expect(breakdown.nodeTier).to.equal(1);
            expect(breakdown.finalTier).to.equal(3);  // ä½¿ç”¨è‡ªç„¶ç­‰çº§
            expect(breakdown.usingNodeTier).to.be.false;
        });

        it("åœºæ™¯4: é Preacherï¼ŒèŠ‚ç‚¹ç­‰çº§æ— æ•ˆ", async function() {
            // user2 æœªè´¨æŠ¼ï¼Œä¸æ˜¯ Preacher
            await staking.connect(tierManager).setNodeTier(user2.address, 1);

            const breakdown = await staking.getUserTierBreakdown(user2.address);
            expect(breakdown.isPreacherStatus).to.be.false;
            expect(breakdown.nodeTier).to.equal(0);  // æ— æ•ˆ
            expect(breakdown.finalTier).to.equal(0);
        });

        it("åœºæ™¯5: ç§»é™¤èŠ‚ç‚¹ç­‰çº§", async function() {
            await staking.connect(tierManager).setNodeTier(user1.address, 1);
            await staking.connect(tierManager).removeNodeTier(user1.address);

            const details = await staking.getNodeTierDetails(user1.address);
            expect(details.isActive).to.be.false;

            const breakdown = await staking.getUserTierBreakdown(user1.address);
            expect(breakdown.nodeTier).to.equal(0);
            expect(breakdown.finalTier).to.equal(0);
        });
    });

    describe("4. æ‰¹é‡æ“ä½œ", function() {
        it("åº”è¯¥èƒ½æ‰¹é‡è®¾ç½®èŠ‚ç‚¹ç­‰çº§", async function() {
            const users = [user1.address, user2.address];
            const tiers = [1, 2];

            await staking.connect(tierManager).batchSetNodeTier(users, tiers);

            const details1 = await staking.getNodeTierDetails(user1.address);
            const details2 = await staking.getNodeTierDetails(user2.address);

            expect(details1.tier).to.equal(1);
            expect(details2.tier).to.equal(2);
        });

        it("åº”æ‹’ç»æ•°ç»„é•¿åº¦ä¸åŒ¹é…", async function() {
            await expect(
                staking.connect(tierManager).batchSetNodeTier(
                    [user1.address],
                    [1, 2]
                )
            ).to.be.revertedWith("NodeTier: array length mismatch");
        });

        it("åº”æ‹’ç»è¶…è¿‡ 100 ä¸ªç”¨æˆ·", async function() {
            const users = new Array(101).fill(user1.address);
            const tiers = new Array(101).fill(1);

            await expect(
                staking.connect(tierManager).batchSetNodeTier(users, tiers)
            ).to.be.revertedWith("NodeTier: max 100 users per batch");
        });
    });

    describe("5. å›¢é˜Ÿå¥–åŠ±åˆ†å‘", function() {
        it("èŠ‚ç‚¹ç­‰çº§ç”¨æˆ·åº”è·å¾—å¯¹åº”æ¯”ä¾‹å¥–åŠ±", async function() {
            // è®¾ç½®æ¨èå…³ç³»: user2 -> user1
            await staking.connect(user1).lockReferral(root.address);
            await staking.connect(user2).lockReferral(user1.address);

            // user1 è´¨æŠ¼ 300 SYI (Preacher)
            await staking.connect(user1).stake(ethers.parseEther("300"), 0);

            // è®¾ç½® user1 ä¸º V1
            await staking.connect(tierManager).setNodeTier(user1.address, 1);

            // user2 è´¨æŠ¼å¹¶è§£è´¨æŠ¼
            await staking.connect(user2).stake(ethers.parseEther("1000"), 0);
            await ethers.provider.send("evm_increaseTime", [86400]); // 1å¤©å
            await staking.connect(user2).unstake(0);

            // éªŒè¯ user1 è·å¾—äº† 5% çš„å¥–åŠ±
            // ï¼ˆéœ€è¦æŸ¥è¯¢ user1 çš„ USDT ä½™é¢å˜åŒ–ï¼‰
        });
    });
});
```

---

### 5.2 é›†æˆæµ‹è¯•åœºæ™¯

#### åœºæ™¯ 1: å®Œæ•´ç”Ÿå‘½å‘¨æœŸ

```javascript
it("å®Œæ•´æµç¨‹: è®¾ç½® -> ä½¿ç”¨ -> å‡çº§ -> ç§»é™¤", async function() {
    // 1. ç”¨æˆ·è´¨æŠ¼æˆä¸º Preacher
    await staking.connect(user1).stake(ethers.parseEther("300"), 0);

    // 2. è®¾ç½®èŠ‚ç‚¹ç­‰çº§ V1
    await staking.connect(tierManager).setNodeTier(user1.address, 1);
    let breakdown = await staking.getUserTierBreakdown(user1.address);
    expect(breakdown.finalTier).to.equal(1);

    // 3. ç”¨æˆ·å›¢é˜Ÿå‘å±•ï¼Œè‡ªç„¶å‡çº§åˆ° V3
    // (æ¨¡æ‹Ÿ teamKPI å¢åŠ )
    breakdown = await staking.getUserTierBreakdown(user1.address);
    expect(breakdown.finalTier).to.equal(3);  // è‡ªç„¶ç­‰çº§ä¼˜å…ˆ
    expect(breakdown.usingNodeTier).to.be.false;

    // 4. ç§»é™¤èŠ‚ç‚¹ç­‰çº§
    await staking.connect(tierManager).removeNodeTier(user1.address);
    breakdown = await staking.getUserTierBreakdown(user1.address);
    expect(breakdown.finalTier).to.equal(3);  // ä»ä¿æŒ V3
});
```

#### åœºæ™¯ 2: æ¨èé“¾ä¸­çš„èŠ‚ç‚¹ç­‰çº§

```javascript
it("æ¨èé“¾ä¸­å¤šä¸ªèŠ‚ç‚¹ç­‰çº§ç”¨æˆ·çš„å¥–åŠ±åˆ†é…", async function() {
    // æ¨èé“¾: user3 -> user2(V1èŠ‚ç‚¹) -> user1(V2èŠ‚ç‚¹) -> root

    // è®¾ç½®æ¨èå…³ç³»
    await staking.connect(user1).lockReferral(root.address);
    await staking.connect(user2).lockReferral(user1.address);
    await staking.connect(user3).lockReferral(user2.address);

    // éƒ½æˆä¸º Preacher
    await staking.connect(user1).stake(ethers.parseEther("300"), 0);
    await staking.connect(user2).stake(ethers.parseEther("300"), 0);

    // è®¾ç½®èŠ‚ç‚¹ç­‰çº§
    await staking.connect(tierManager).setNodeTier(user1.address, 2);
    await staking.connect(tierManager).setNodeTier(user2.address, 1);

    // user3 è§£è´¨æŠ¼
    await staking.connect(user3).stake(ethers.parseEther("1000"), 0);
    await ethers.provider.send("evm_increaseTime", [86400]);
    await staking.connect(user3).unstake(0);

    // éªŒè¯:
    // - user2 åº”è·å¾— 5% (V1)
    // - user1 åº”è·å¾— 5% (V2-V1 å·®é¢)
    // - root è·å¾—å‰©ä½™ 25%
});
```

---

### 5.3 Gas æµ‹è¯•

```javascript
describe("Gas æˆæœ¬æµ‹è¯•", function() {
    it("è®¾ç½®å•ä¸ªèŠ‚ç‚¹ç­‰çº§çš„ Gas æˆæœ¬", async function() {
        const tx = await staking.connect(tierManager).setNodeTier(user1.address, 1);
        const receipt = await tx.wait();
        console.log("setNodeTier gas:", receipt.gasUsed.toString());
        expect(receipt.gasUsed).to.be.lessThan(50000);
    });

    it("æ‰¹é‡è®¾ç½® 10 ä¸ªç”¨æˆ·çš„ Gas æˆæœ¬", async function() {
        const users = new Array(10).fill(user1.address);
        const tiers = new Array(10).fill(1);

        const tx = await staking.connect(tierManager).batchSetNodeTier(users, tiers);
        const receipt = await tx.wait();
        console.log("batchSetNodeTier (10) gas:", receipt.gasUsed.toString());
    });

    it("unstake æ—¶ä½¿ç”¨èŠ‚ç‚¹ç­‰çº§çš„é¢å¤– Gas", async function() {
        await staking.connect(user1).stake(ethers.parseEther("300"), 0);

        // ä¸ä½¿ç”¨èŠ‚ç‚¹ç­‰çº§
        await ethers.provider.send("evm_increaseTime", [86400]);
        const tx1 = await staking.connect(user1).unstake(0);
        const receipt1 = await tx1.wait();

        // ä½¿ç”¨èŠ‚ç‚¹ç­‰çº§
        await staking.connect(tierManager).setNodeTier(user2.address, 1);
        await staking.connect(user2).stake(ethers.parseEther("300"), 0);
        await ethers.provider.send("evm_increaseTime", [86400]);
        const tx2 = await staking.connect(user2).unstake(0);
        const receipt2 = await tx2.wait();

        console.log("unstake without node tier:", receipt1.gasUsed.toString());
        console.log("unstake with node tier:", receipt2.gasUsed.toString());
        console.log("difference:", (receipt2.gasUsed - receipt1.gasUsed).toString());
    });
});
```

---

## éƒ¨ç½²ä¸å‡çº§æŒ‡å—

### 6.1 éƒ¨ç½²æ­¥éª¤

#### æ­¥éª¤ 1: ä¿®æ”¹åˆçº¦ä»£ç 

æŒ‰ç…§"å®Œæ•´å®ç°ä»£ç "ç« èŠ‚ä¿®æ”¹ä»¥ä¸‹æ–‡ä»¶ï¼š
- `contracts/SYI-Staking/abstract/StakingBase.sol`

#### æ­¥éª¤ 2: ç¼–è¯‘åˆçº¦

```bash
npx hardhat compile
```

éªŒè¯ç¼–è¯‘æ— é”™è¯¯ã€‚

#### æ­¥éª¤ 3: éƒ¨ç½²æ–°åˆçº¦

```bash
# éƒ¨ç½²åˆ°æœ¬åœ°æµ‹è¯•ç½‘
npx hardhat run scripts/deployOLASystem.js --network localhost

# æˆ–éƒ¨ç½²åˆ° BSC æµ‹è¯•ç½‘
npx hardhat run scripts/deployOLASystem.js --network bscTestnet
```

#### æ­¥éª¤ 4: è®¾ç½® tierManager

```javascript
// scripts/setTierManager.js
const { ethers } = require("hardhat");

async function main() {
    const [deployer, tierManager] = await ethers.getSigners();

    const stakingAddress = "0x..."; // ä» deployed-addresses.json è·å–
    const Staking = await ethers.getContractAt("Staking", stakingAddress);

    console.log("Setting tier manager to:", tierManager.address);
    const tx = await Staking.setTierManager(tierManager.address);
    await tx.wait();

    console.log("Tier manager set successfully");
    console.log("Current tier manager:", await Staking.tierManager());
}

main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
```

è¿è¡Œ:
```bash
npx hardhat run scripts/setTierManager.js --network localhost
```

---

### 6.2 å‡çº§ç°æœ‰åˆçº¦

å¦‚æœå·²æœ‰è¿è¡Œä¸­çš„åˆçº¦ï¼Œéœ€è¦ä½¿ç”¨ä»£ç†æ¨¡å¼å‡çº§ã€‚

#### æ–¹æ¡ˆ A: é€æ˜ä»£ç†ï¼ˆæ¨èï¼‰

```javascript
// ä½¿ç”¨ OpenZeppelin çš„ Transparent Proxy
const { ethers, upgrades } = require("hardhat");

async function upgrade() {
    const proxyAddress = "0x..."; // ç°æœ‰ä»£ç†åœ°å€

    const StakingV2 = await ethers.getContractFactory("Staking");
    console.log("Upgrading Staking...");

    const upgraded = await upgrades.upgradeProxy(proxyAddress, StakingV2);
    await upgraded.deployed();

    console.log("Staking upgraded at:", upgraded.address);

    // éªŒè¯æ–°åŠŸèƒ½
    console.log("Tier manager:", await upgraded.tierManager());
}

upgrade();
```

#### æ–¹æ¡ˆ B: é‡æ–°éƒ¨ç½² + æ•°æ®è¿ç§»

å¦‚æœæœªä½¿ç”¨ä»£ç†ï¼Œéœ€è¦ï¼š
1. éƒ¨ç½²æ–°åˆçº¦
2. æš‚åœæ—§åˆçº¦
3. è¿ç§»ç”¨æˆ·æ•°æ®ï¼ˆè´¨æŠ¼è®°å½•ã€æ¨èå…³ç³»ç­‰ï¼‰
4. åˆ‡æ¢å‰ç«¯æŒ‡å‘æ–°åˆçº¦

âš ï¸ **é£é™©é«˜ï¼Œéœ€è¦è¯¦ç»†è®¡åˆ’**

---

### 6.3 éªŒè¯éƒ¨ç½²

```javascript
// scripts/verifyNodeTierSystem.js
async function verify() {
    const staking = await ethers.getContractAt("Staking", stakingAddress);

    // 1. æ£€æŸ¥ tierManager æ˜¯å¦è®¾ç½®
    const tierManager = await staking.tierManager();
    console.log("âœ“ Tier manager:", tierManager);

    // 2. æµ‹è¯•è®¾ç½®èŠ‚ç‚¹ç­‰çº§
    const [_, manager, testUser] = await ethers.getSigners();
    await staking.connect(manager).setNodeTier(testUser.address, 1);
    console.log("âœ“ setNodeTier works");

    // 3. æµ‹è¯•æŸ¥è¯¢
    const details = await staking.getNodeTierDetails(testUser.address);
    console.log("âœ“ Node tier details:", details);

    // 4. æµ‹è¯•ç§»é™¤
    await staking.connect(manager).removeNodeTier(testUser.address);
    console.log("âœ“ removeNodeTier works");

    console.log("\nâœ… All checks passed!");
}

verify();
```

---

### 6.4 å‰ç«¯é›†æˆ

#### ç›‘å¬äº‹ä»¶

```javascript
// ç›‘å¬èŠ‚ç‚¹ç­‰çº§è®¾ç½®
staking.on("NodeTierSet", (user, tier, setBy, timestamp) => {
    console.log(`ç”¨æˆ· ${user} è¢«è®¾ç½®ä¸º V${tier}`);
    // æ›´æ–° UI
});

// ç›‘å¬èŠ‚ç‚¹ç­‰çº§ä½¿ç”¨
staking.on("NodeTierUsed", (user, naturalTier, nodeTier, finalTier, reason) => {
    console.log(`ç”¨æˆ· ${user} ä½¿ç”¨èŠ‚ç‚¹ç­‰çº§ V${nodeTier} (è‡ªç„¶ç­‰çº§: V${naturalTier})`);
});
```

#### æŸ¥è¯¢ç”¨æˆ·ç­‰çº§

```javascript
async function getUserFullInfo(userAddress) {
    const breakdown = await staking.getUserTierBreakdown(userAddress);

    return {
        isPreacher: breakdown.isPreacherStatus,
        naturalTier: breakdown.naturalTier,
        nodeTier: breakdown.nodeTier,
        finalTier: breakdown.finalTier,
        usingNodeTier: breakdown.usingNodeTier
    };
}

// æ˜¾ç¤º
const info = await getUserFullInfo("0x...");
console.log(`
å½“å‰ç­‰çº§: V${info.finalTier} ${info.usingNodeTier ? 'â­ (èŠ‚ç‚¹ç­‰çº§)' : ''}
è‡ªç„¶ç­‰çº§: V${info.naturalTier}
èŠ‚ç‚¹ç­‰çº§: V${info.nodeTier}
Preacher: ${info.isPreacher ? 'æ˜¯' : 'å¦'}
`);
```

#### ç®¡ç†ç•Œé¢

```javascript
// tierManager ä¸“ç”¨ç®¡ç†é¢æ¿
async function setNodeTier(userAddress, tier) {
    try {
        const tx = await staking.connect(tierManager).setNodeTier(userAddress, tier);
        await tx.wait();
        alert(`æˆåŠŸè®¾ç½® ${userAddress} ä¸º V${tier}`);
    } catch (error) {
        alert(`è®¾ç½®å¤±è´¥: ${error.message}`);
    }
}

async function batchSetNodeTier(userList, tierList) {
    if (userList.length > 100) {
        alert("æ¯æ¬¡æœ€å¤šå¤„ç† 100 ä¸ªç”¨æˆ·");
        return;
    }

    const tx = await staking.connect(tierManager).batchSetNodeTier(userList, tierList);
    await tx.wait();
    alert(`æ‰¹é‡è®¾ç½®æˆåŠŸ: ${userList.length} ä¸ªç”¨æˆ·`);
}
```

---

## æ€»ç»“

### å®ç°è¦ç‚¹

| é¡¹ç›® | è¯´æ˜ |
|------|------|
| **æ–°å¢è§’è‰²** | `tierManager` åœ°å€ï¼Œç”± owner è®¾ç½® |
| **æ–°å¢çŠ¶æ€å˜é‡** | `nodeTiers` mapping (27 bytes/ç”¨æˆ·) |
| **æ ¸å¿ƒé€»è¾‘** | `finalTier = MAX(naturalTier, nodeTier)` |
| **æƒé™æ§åˆ¶** | `onlyTierManager` ä¿®é¥°å™¨ |
| **ç­‰çº§é™åˆ¶** | ä»…æ”¯æŒ V1 (1) å’Œ V2 (2) |
| **Preacher æ£€æŸ¥** | ä»éœ€æ»¡è¶³ â‰¥ 200 SYI |

### ä»£ç ä¿®æ”¹é‡

- **æ–°å¢ä»£ç **: ~250 è¡Œï¼ˆå‡½æ•° + ç»“æ„ä½“ + äº‹ä»¶ï¼‰
- **ä¿®æ”¹ä»£ç **: ~30 è¡Œï¼ˆ`_getUserTier` + `_calculateNaturalTier`ï¼‰
- **æµ‹è¯•ä»£ç **: ~400 è¡Œï¼ˆå®Œæ•´æµ‹è¯•å¥—ä»¶ï¼‰

### å¼€å‘æ—¶é—´ä¼°ç®—

| é˜¶æ®µ | æ—¶é—´ |
|------|------|
| ä»£ç å®ç° | 4-6 å°æ—¶ |
| å•å…ƒæµ‹è¯• | 4-6 å°æ—¶ |
| é›†æˆæµ‹è¯• | 2-3 å°æ—¶ |
| å‰ç«¯é›†æˆ | 3-4 å°æ—¶ |
| å®¡è®¡å‡†å¤‡ | 2-3 å°æ—¶ |
| **æ€»è®¡** | **15-22 å°æ—¶** |

### é£é™©ç­‰çº§

| ç±»åˆ« | ç­‰çº§ | è¯´æ˜ |
|------|------|------|
| **æŠ€æœ¯é£é™©** | ğŸŸ¢ ä½ | é€»è¾‘ç®€å•ï¼Œå½±å“å¯æ§ |
| **å®‰å…¨é£é™©** | ğŸŸ¡ ä¸­ | éœ€è¦å®¡è®¡ tierManager æƒé™ |
| **Gas æˆæœ¬** | ğŸŸ¢ ä½ | å¢åŠ  < 1% |
| **ç”¨æˆ·ä½“éªŒ** | ğŸŸ¢ ä½ | é€æ˜å¯æŸ¥è¯¢ |

### å»ºè®®å®æ–½è·¯å¾„

1. âœ… **æœ¬åœ°æµ‹è¯•**: å®Œæˆæ‰€æœ‰å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
2. âœ… **æµ‹è¯•ç½‘éƒ¨ç½²**: BSC æµ‹è¯•ç½‘è¿è¡Œ 1-2 å‘¨
3. âš ï¸ **å®‰å…¨å®¡è®¡**: è˜è¯·ä¸“ä¸šå®¡è®¡å…¬å¸
4. âœ… **ä¸»ç½‘éƒ¨ç½²**: ä½¿ç”¨å¤šç­¾é’±åŒ…éƒ¨ç½²
5. âœ… **ç›‘æ§**: ç›‘å¬æ‰€æœ‰èŠ‚ç‚¹ç­‰çº§ç›¸å…³äº‹ä»¶

---

## é™„å½•

### A. å®Œæ•´äº‹ä»¶åˆ—è¡¨

```solidity
event TierManagerUpdated(address indexed oldManager, address indexed newManager, address indexed operator, uint256 timestamp);
event NodeTierSet(address indexed user, uint8 tier, address indexed setBy, uint256 timestamp);
event NodeTierRemoved(address indexed user, uint8 previousTier, address indexed removedBy, uint256 timestamp);
event NodeTierBatchSet(address[] users, uint8[] tiers, address indexed setBy, uint256 count, uint256 timestamp);
event NodeTierUsed(address indexed user, uint8 naturalTier, uint8 nodeTier, uint8 finalTier, string reason);
```

### B. é”™è¯¯æ¶ˆæ¯åˆ—è¡¨

```solidity
"Caller is not tier manager"
"NodeTier: invalid address"
"NodeTier: cannot set for root"
"NodeTier: only tier 1 or 2 allowed"
"NodeTier: no active tier"
"NodeTier: array length mismatch"
"NodeTier: empty array"
"NodeTier: max 100 users per batch"
"NodeTier: invalid address in batch"
"NodeTier: invalid tier in batch"
```

### C. Gas ä¼˜åŒ–å»ºè®®

1. **æ‰¹é‡æ“ä½œ**: ä½¿ç”¨ `batchSetNodeTier` è€Œä¸æ˜¯å¾ªç¯è°ƒç”¨
2. **å­˜å‚¨æ‰“åŒ…**: `NodeTierRecord` å·²ä¼˜åŒ–ä¸º 1 ä¸ª slot
3. **äº‹ä»¶ç´¢å¼•**: åªç´¢å¼•å¿…è¦çš„å‚æ•°ï¼ˆæœ€å¤š 3 ä¸ªï¼‰
4. **ç¼“å­˜è¯»å–**: åœ¨å¾ªç¯ä¸­ç¼“å­˜ `nodeTiers[user]`

### D. å‚è€ƒèµ„æ–™

- [OpenZeppelin Ownable](https://docs.openzeppelin.com/contracts/4.x/access-control)
- [Solidity Gas ä¼˜åŒ–](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc)
- [Uniswap V2 Whitepaper](https://uniswap.org/whitepaper.pdf)
